{"version":3,"file":"605-f89de0f25e64a774a84e.js","mappings":"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","sources":["webpack://jaen-template-shopify/./node_modules/@snek-functions/agt-users/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import _asyncToGenerator from \"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/home/runner/work/shop/shop/node_modules/@babel/runtime/regenerator/index.js\";\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(value) { var ret = this.s.return; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, throw: function _throw(value) { var thr = this.s.return; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }\nimport { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nvar s = 0;\nvar S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nvar f = 1;\nvar F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nvar LF = 10;\nvar CR = 13;\nvar SPACE = 32;\nvar HYPHEN = 45;\nvar COLON = 58;\nvar A = 97;\nvar Z = 122;\nvar lower = function lower(c) {\n  return c | 0x20;\n};\nvar noop = function noop() {};\nvar MultipartParser = /*#__PURE__*/function () {\n  /**\n   * @param {string} boundary\n   */\n  function MultipartParser(boundary) {\n    _classCallCheck(this, MultipartParser);\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    var ui8a = new Uint8Array(boundary.length);\n    for (var i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  _createClass(MultipartParser, [{\n    key: \"write\",\n    value: function write(data) {\n      var _this = this;\n      var i = 0;\n      var length_ = data.length;\n      var previousIndex = this.index;\n      var lookbehind = this.lookbehind,\n        boundary = this.boundary,\n        boundaryChars = this.boundaryChars,\n        index = this.index,\n        state = this.state,\n        flags = this.flags;\n      var boundaryLength = this.boundary.length;\n      var boundaryEnd = boundaryLength - 1;\n      var bufferLength = data.length;\n      var c;\n      var cl;\n      var mark = function mark(name) {\n        _this[name + 'Mark'] = i;\n      };\n      var clear = function clear(name) {\n        delete _this[name + 'Mark'];\n      };\n      var callback = function callback(callbackSymbol, start, end, ui8a) {\n        if (start === undefined || start !== end) {\n          _this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n        }\n      };\n      var dataCallback = function dataCallback(name, clear) {\n        var markSymbol = name + 'Mark';\n        if (!(markSymbol in _this)) {\n          return;\n        }\n        if (clear) {\n          callback(name, _this[markSymbol], i, data);\n          delete _this[markSymbol];\n        } else {\n          callback(name, _this[markSymbol], data.length, data);\n          _this[markSymbol] = 0;\n        }\n      };\n      for (i = 0; i < length_; i++) {\n        c = data[i];\n        switch (state) {\n          case S.START_BOUNDARY:\n            if (index === boundary.length - 2) {\n              if (c === HYPHEN) {\n                flags |= F.LAST_BOUNDARY;\n              } else if (c !== CR) {\n                return;\n              }\n              index++;\n              break;\n            } else if (index - 1 === boundary.length - 2) {\n              if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n                state = S.END;\n                flags = 0;\n              } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n                index = 0;\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n              } else {\n                return;\n              }\n              break;\n            }\n            if (c !== boundary[index + 2]) {\n              index = -2;\n            }\n            if (c === boundary[index + 2]) {\n              index++;\n            }\n            break;\n          case S.HEADER_FIELD_START:\n            state = S.HEADER_FIELD;\n            mark('onHeaderField');\n            index = 0;\n          // falls through\n          case S.HEADER_FIELD:\n            if (c === CR) {\n              clear('onHeaderField');\n              state = S.HEADERS_ALMOST_DONE;\n              break;\n            }\n            index++;\n            if (c === HYPHEN) {\n              break;\n            }\n            if (c === COLON) {\n              if (index === 1) {\n                // empty header field\n                return;\n              }\n              dataCallback('onHeaderField', true);\n              state = S.HEADER_VALUE_START;\n              break;\n            }\n            cl = lower(c);\n            if (cl < A || cl > Z) {\n              return;\n            }\n            break;\n          case S.HEADER_VALUE_START:\n            if (c === SPACE) {\n              break;\n            }\n            mark('onHeaderValue');\n            state = S.HEADER_VALUE;\n          // falls through\n          case S.HEADER_VALUE:\n            if (c === CR) {\n              dataCallback('onHeaderValue', true);\n              callback('onHeaderEnd');\n              state = S.HEADER_VALUE_ALMOST_DONE;\n            }\n            break;\n          case S.HEADER_VALUE_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            state = S.HEADER_FIELD_START;\n            break;\n          case S.HEADERS_ALMOST_DONE:\n            if (c !== LF) {\n              return;\n            }\n            callback('onHeadersEnd');\n            state = S.PART_DATA_START;\n            break;\n          case S.PART_DATA_START:\n            state = S.PART_DATA;\n            mark('onPartData');\n          // falls through\n          case S.PART_DATA:\n            previousIndex = index;\n            if (index === 0) {\n              // boyer-moore derrived algorithm to safely skip non-boundary data\n              i += boundaryEnd;\n              while (i < bufferLength && !(data[i] in boundaryChars)) {\n                i += boundaryLength;\n              }\n              i -= boundaryEnd;\n              c = data[i];\n            }\n            if (index < boundary.length) {\n              if (boundary[index] === c) {\n                if (index === 0) {\n                  dataCallback('onPartData', true);\n                }\n                index++;\n              } else {\n                index = 0;\n              }\n            } else if (index === boundary.length) {\n              index++;\n              if (c === CR) {\n                // CR = part boundary\n                flags |= F.PART_BOUNDARY;\n              } else if (c === HYPHEN) {\n                // HYPHEN = end boundary\n                flags |= F.LAST_BOUNDARY;\n              } else {\n                index = 0;\n              }\n            } else if (index - 1 === boundary.length) {\n              if (flags & F.PART_BOUNDARY) {\n                index = 0;\n                if (c === LF) {\n                  // unset the PART_BOUNDARY flag\n                  flags &= ~F.PART_BOUNDARY;\n                  callback('onPartEnd');\n                  callback('onPartBegin');\n                  state = S.HEADER_FIELD_START;\n                  break;\n                }\n              } else if (flags & F.LAST_BOUNDARY) {\n                if (c === HYPHEN) {\n                  callback('onPartEnd');\n                  state = S.END;\n                  flags = 0;\n                } else {\n                  index = 0;\n                }\n              } else {\n                index = 0;\n              }\n            }\n            if (index > 0) {\n              // when matching a possible boundary, keep a lookbehind reference\n              // in case it turns out to be a false lead\n              lookbehind[index - 1] = c;\n            } else if (previousIndex > 0) {\n              // if our boundary turned out to be rubbish, the captured lookbehind\n              // belongs to partData\n              var _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n              callback('onPartData', 0, previousIndex, _lookbehind);\n              previousIndex = 0;\n              mark('onPartData');\n\n              // reconsider the current character even so it interrupted the sequence\n              // it could be the beginning of a new sequence\n              i--;\n            }\n            break;\n          case S.END:\n            break;\n          default:\n            throw new Error(\"Unexpected state entered: \".concat(state));\n        }\n      }\n      dataCallback('onHeaderField');\n      dataCallback('onHeaderValue');\n      dataCallback('onPartData');\n\n      // Update properties for the next call\n      this.index = index;\n      this.state = state;\n      this.flags = flags;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n        this.onPartEnd();\n      } else if (this.state !== S.END) {\n        throw new Error('MultipartParser.end(): stream ended unexpectedly');\n      }\n    }\n  }]);\n  return MultipartParser;\n}();\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  var m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n  if (!m) {\n    return;\n  }\n  var match = m[2] || m[3] || '';\n  var filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, function (m, code) {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\nexport function toFormData(_x, _x2) {\n  return _toFormData.apply(this, arguments);\n}\nfunction _toFormData() {\n  _toFormData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(Body, ct) {\n    var m, parser, headerField, headerValue, entryValue, entryName, contentType, filename, entryChunks, formData, onPartData, appendToFile, appendFileToFormData, appendEntryToFormData, decoder, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (/multipart/i.test(ct)) {\n              _context.next = 2;\n              break;\n            }\n            throw new TypeError('Failed to fetch');\n          case 2:\n            m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n            if (m) {\n              _context.next = 5;\n              break;\n            }\n            throw new TypeError('no or bad content-type header, no multipart boundary');\n          case 5:\n            parser = new MultipartParser(m[1] || m[2]);\n            entryChunks = [];\n            formData = new FormData();\n            onPartData = function onPartData(ui8a) {\n              entryValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            appendToFile = function appendToFile(ui8a) {\n              entryChunks.push(ui8a);\n            };\n            appendFileToFormData = function appendFileToFormData() {\n              var file = new File(entryChunks, filename, {\n                type: contentType\n              });\n              formData.append(entryName, file);\n            };\n            appendEntryToFormData = function appendEntryToFormData() {\n              formData.append(entryName, entryValue);\n            };\n            decoder = new TextDecoder('utf-8');\n            decoder.decode();\n            parser.onPartBegin = function () {\n              parser.onPartData = onPartData;\n              parser.onPartEnd = appendEntryToFormData;\n              headerField = '';\n              headerValue = '';\n              entryValue = '';\n              entryName = '';\n              contentType = '';\n              filename = null;\n              entryChunks.length = 0;\n            };\n            parser.onHeaderField = function (ui8a) {\n              headerField += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            parser.onHeaderValue = function (ui8a) {\n              headerValue += decoder.decode(ui8a, {\n                stream: true\n              });\n            };\n            parser.onHeaderEnd = function () {\n              headerValue += decoder.decode();\n              headerField = headerField.toLowerCase();\n              if (headerField === 'content-disposition') {\n                // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n                var _m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n                if (_m) {\n                  entryName = _m[2] || _m[3] || '';\n                }\n                filename = _fileName(headerValue);\n                if (filename) {\n                  parser.onPartData = appendToFile;\n                  parser.onPartEnd = appendFileToFormData;\n                }\n              } else if (headerField === 'content-type') {\n                contentType = headerValue;\n              }\n              headerValue = '';\n              headerField = '';\n            };\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 20;\n            _iterator = _asyncIterator(Body);\n          case 22:\n            _context.next = 24;\n            return _iterator.next();\n          case 24:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 30;\n              break;\n            }\n            chunk = _step.value;\n            parser.write(chunk);\n          case 27:\n            _iteratorAbruptCompletion = false;\n            _context.next = 22;\n            break;\n          case 30:\n            _context.next = 36;\n            break;\n          case 32:\n            _context.prev = 32;\n            _context.t0 = _context[\"catch\"](20);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 36:\n            _context.prev = 36;\n            _context.prev = 37;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 41;\n              break;\n            }\n            _context.next = 41;\n            return _iterator.return();\n          case 41:\n            _context.prev = 41;\n            if (!_didIteratorError) {\n              _context.next = 44;\n              break;\n            }\n            throw _iteratorError;\n          case 44:\n            return _context.finish(41);\n          case 45:\n            return _context.finish(36);\n          case 46:\n            parser.end();\n            return _context.abrupt(\"return\", formData);\n          case 48:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[20, 32, 36, 46], [37,, 41, 45]]);\n  }));\n  return _toFormData.apply(this, arguments);\n}"],"names":["_asyncIterator","iterable","method","async","sync","retry","Symbol","asyncIterator","iterator","call","AsyncFromSyncIterator","TypeError","s","AsyncFromSyncIteratorContinuation","r","Object","Promise","reject","done","resolve","value","then","this","n","next","prototype","apply","arguments","return","ret","throw","thr","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","lower","c","noop","MultipartParser","boundary","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","key","data","cl","_this","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","mark","name","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","clear","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","concat","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","_x","_x2","_toFormData","_callee","Body","ct","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","appendToFile","appendFileToFormData","appendEntryToFormData","decoder","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","chunk","_context","prev","test","decode","stream","push","file","type","append","TextDecoder","toLowerCase","_m","sent","write","t0","finish","abrupt","stop"],"sourceRoot":""}