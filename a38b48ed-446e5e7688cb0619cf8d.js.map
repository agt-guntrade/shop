{"version":3,"file":"a38b48ed-446e5e7688cb0619cf8d.js","mappings":"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","sources":["webpack://jaen-template-shopify/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js"],"sourcesContent":["var _regeneratorRuntime = require(\"/home/runner/work/shop/shop/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _classCallCheck = require(\"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/classCallCheck.js\");\n\nvar _createClass = require(\"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/createClass.js\");\n\nvar _awaitAsyncGenerator = require(\"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\");\n\nvar _wrapAsyncGenerator = require(\"/home/runner/work/shop/shop/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\");\n\nrequire(\"core-js/modules/esnext.global-this.js\");\n\n/**\n * web-streams-polyfill v3.2.1\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.WebStreamsPolyfill = {}));\n})(this, function (exports) {\n  'use strict'; /// <reference lib=\"es2015.symbol\" />\n\n  var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {\n    return \"Symbol(\".concat(description, \")\");\n  }; /// <reference lib=\"dom\" />\n\n  function noop() {\n    return undefined;\n  }\n\n  function getGlobals() {\n    if (typeof self !== 'undefined') {\n      return self;\n    } else if (typeof window !== 'undefined') {\n      return window;\n    } else if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    return undefined;\n  }\n\n  var globals = getGlobals();\n\n  function typeIsObject(x) {\n    return typeof x === 'object' && x !== null || typeof x === 'function';\n  }\n\n  var rethrowAssertionErrorRejection = noop;\n  var originalPromise = Promise;\n  var originalPromiseThen = Promise.prototype.then;\n  var originalPromiseResolve = Promise.resolve.bind(originalPromise);\n  var originalPromiseReject = Promise.reject.bind(originalPromise);\n\n  function newPromise(executor) {\n    return new originalPromise(executor);\n  }\n\n  function promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n  }\n\n  function promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n  }\n\n  function PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n  }\n\n  function uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n  }\n\n  function uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n  }\n\n  function uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n  }\n\n  function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n  }\n\n  function setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n  }\n\n  var queueMicrotask = function () {\n    var globalQueueMicrotask = globals && globals.queueMicrotask;\n\n    if (typeof globalQueueMicrotask === 'function') {\n      return globalQueueMicrotask;\n    }\n\n    var resolvedPromise = promiseResolvedWith(undefined);\n    return function (fn) {\n      return PerformPromiseThen(resolvedPromise, fn);\n    };\n  }();\n\n  function reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n      throw new TypeError('Argument is not a function');\n    }\n\n    return Function.prototype.apply.call(F, V, args);\n  }\n\n  function promiseCall(F, V, args) {\n    try {\n      return promiseResolvedWith(reflectCall(F, V, args));\n    } catch (value) {\n      return promiseRejectedWith(value);\n    }\n  } // Original from Chromium\n  // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n\n\n  var QUEUE_MAX_ARRAY_SIZE = 16384;\n  /**\n   * Simple queue structure.\n   *\n   * Avoids scalability issues with using a packed array directly by using\n   * multiple arrays in a linked list and keeping the array size bounded.\n   */\n\n  var SimpleQueue = /*#__PURE__*/function () {\n    function SimpleQueue() {\n      _classCallCheck(this, SimpleQueue);\n\n      this._cursor = 0;\n      this._size = 0; // _front and _back are always defined.\n\n      this._front = {\n        _elements: [],\n        _next: undefined\n      };\n      this._back = this._front; // The cursor is used to avoid calling Array.shift().\n      // It contains the index of the front element of the array inside the\n      // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n\n      this._cursor = 0; // When there is only one node, size === elements.length - cursor.\n\n      this._size = 0;\n    }\n\n    _createClass(SimpleQueue, [{\n      key: \"length\",\n      get: function get() {\n        return this._size;\n      } // For exception safety, this method is structured in order:\n      // 1. Read state\n      // 2. Calculate required state mutations\n      // 3. Perform state mutations\n\n    }, {\n      key: \"push\",\n      value: function push(element) {\n        var oldBack = this._back;\n        var newBack = oldBack;\n\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n          newBack = {\n            _elements: [],\n            _next: undefined\n          };\n        } // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n\n\n        oldBack._elements.push(element);\n\n        if (newBack !== oldBack) {\n          this._back = newBack;\n          oldBack._next = newBack;\n        }\n\n        ++this._size;\n      } // Like push(), shift() follows the read -> calculate -> mutate pattern for\n      // exception safety.\n\n    }, {\n      key: \"shift\",\n      value: function shift() {\n        // must not be called on an empty queue\n        var oldFront = this._front;\n        var newFront = oldFront;\n        var oldCursor = this._cursor;\n        var newCursor = oldCursor + 1;\n        var elements = oldFront._elements;\n        var element = elements[oldCursor];\n\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n          newFront = oldFront._next;\n          newCursor = 0;\n        } // No mutations before this point.\n\n\n        --this._size;\n        this._cursor = newCursor;\n\n        if (oldFront !== newFront) {\n          this._front = newFront;\n        } // Permit shifted element to be garbage collected.\n\n\n        elements[oldCursor] = undefined;\n        return element;\n      } // The tricky thing about forEach() is that it can be called\n      // re-entrantly. The queue may be mutated inside the callback. It is easy to\n      // see that push() within the callback has no negative effects since the end\n      // of the queue is checked for on every iteration. If shift() is called\n      // repeatedly within the callback then the next iteration may return an\n      // element that has been removed. In this case the callback will be called\n      // with undefined values until we either \"catch up\" with elements that still\n      // exist or reach the back of the queue.\n\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        var i = this._cursor;\n        var node = this._front;\n        var elements = node._elements;\n\n        while (i !== elements.length || node._next !== undefined) {\n          if (i === elements.length) {\n            node = node._next;\n            elements = node._elements;\n            i = 0;\n\n            if (elements.length === 0) {\n              break;\n            }\n          }\n\n          callback(elements[i]);\n          ++i;\n        }\n      } // Return the element that would be returned if shift() was called now,\n      // without modifying the queue.\n\n    }, {\n      key: \"peek\",\n      value: function peek() {\n        // must not be called on an empty queue\n        var front = this._front;\n        var cursor = this._cursor;\n        return front._elements[cursor];\n      }\n    }]);\n\n    return SimpleQueue;\n  }();\n\n  function ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n\n    if (stream._state === 'readable') {\n      defaultReaderClosedPromiseInitialize(reader);\n    } else if (stream._state === 'closed') {\n      defaultReaderClosedPromiseInitializeAsResolved(reader);\n    } else {\n      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n  } // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n  // check.\n\n\n  function ReadableStreamReaderGenericCancel(reader, reason) {\n    var stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n  }\n\n  function ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n      defaultReaderClosedPromiseReject(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n    } else {\n      defaultReaderClosedPromiseResetToRejected(reader, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\"));\n    }\n\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n  } // Helper functions for the readers.\n\n\n  function readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n  } // Helper functions for the ReadableStreamDefaultReader.\n\n\n  function defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise(function (resolve, reject) {\n      reader._closedPromise_resolve = resolve;\n      reader._closedPromise_reject = reject;\n    });\n  }\n\n  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n  }\n\n  function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n  }\n\n  function defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n      return;\n    }\n\n    setPromiseIsHandledToTrue(reader._closedPromise);\n\n    reader._closedPromise_reject(reason);\n\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n  }\n\n  function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n  }\n\n  function defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n      return;\n    }\n\n    reader._closedPromise_resolve(undefined);\n\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n  }\n\n  var AbortSteps = SymbolPolyfill('[[AbortSteps]]');\n  var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n  var CancelSteps = SymbolPolyfill('[[CancelSteps]]');\n  var PullSteps = SymbolPolyfill('[[PullSteps]]'); /// <reference lib=\"es2015.core\" />\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n\n  var NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n  }; /// <reference lib=\"es2015.core\" />\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n\n\n  var MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n  }; // https://heycam.github.io/webidl/#idl-dictionaries\n\n\n  function isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n  }\n\n  function assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n      throw new TypeError(\"\".concat(context, \" is not an object.\"));\n    }\n  } // https://heycam.github.io/webidl/#idl-callback-functions\n\n\n  function assertFunction(x, context) {\n    if (typeof x !== 'function') {\n      throw new TypeError(\"\".concat(context, \" is not a function.\"));\n    }\n  } // https://heycam.github.io/webidl/#idl-object\n\n\n  function isObject(x) {\n    return typeof x === 'object' && x !== null || typeof x === 'function';\n  }\n\n  function assertObject(x, context) {\n    if (!isObject(x)) {\n      throw new TypeError(\"\".concat(context, \" is not an object.\"));\n    }\n  }\n\n  function assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n      throw new TypeError(\"Parameter \".concat(position, \" is required in '\").concat(context, \"'.\"));\n    }\n  }\n\n  function assertRequiredField(x, field, context) {\n    if (x === undefined) {\n      throw new TypeError(\"\".concat(field, \" is required in '\").concat(context, \"'.\"));\n    }\n  } // https://heycam.github.io/webidl/#idl-unrestricted-double\n\n\n  function convertUnrestrictedDouble(value) {\n    return Number(value);\n  }\n\n  function censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n  }\n\n  function integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n  } // https://heycam.github.io/webidl/#idl-unsigned-long-long\n\n\n  function convertUnsignedLongLongWithEnforceRange(value, context) {\n    var lowerBound = 0;\n    var upperBound = Number.MAX_SAFE_INTEGER;\n    var x = Number(value);\n    x = censorNegativeZero(x);\n\n    if (!NumberIsFinite(x)) {\n      throw new TypeError(\"\".concat(context, \" is not a finite number\"));\n    }\n\n    x = integerPart(x);\n\n    if (x < lowerBound || x > upperBound) {\n      throw new TypeError(\"\".concat(context, \" is outside the accepted range of \").concat(lowerBound, \" to \").concat(upperBound, \", inclusive\"));\n    }\n\n    if (!NumberIsFinite(x) || x === 0) {\n      return 0;\n    } // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n\n\n    return x;\n  }\n\n  function assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n      throw new TypeError(\"\".concat(context, \" is not a ReadableStream.\"));\n    }\n  } // Abstract operations for the ReadableStream.\n\n\n  function AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n  } // ReadableStream API exposed for controllers.\n\n\n  function ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n  }\n\n  function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    var reader = stream._reader;\n\n    var readRequest = reader._readRequests.shift();\n\n    if (done) {\n      readRequest._closeSteps();\n    } else {\n      readRequest._chunkSteps(chunk);\n    }\n  }\n\n  function ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n  }\n\n  function ReadableStreamHasDefaultReader(stream) {\n    var reader = stream._reader;\n\n    if (reader === undefined) {\n      return false;\n    }\n\n    if (!IsReadableStreamDefaultReader(reader)) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * A default reader vended by a {@link ReadableStream}.\n   *\n   * @public\n   */\n\n\n  var ReadableStreamDefaultReader = /*#__PURE__*/function () {\n    function ReadableStreamDefaultReader(stream) {\n      _classCallCheck(this, ReadableStreamDefaultReader);\n\n      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n      assertReadableStream(stream, 'First parameter');\n\n      if (IsReadableStreamLocked(stream)) {\n        throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n      }\n\n      ReadableStreamReaderGenericInitialize(this, stream);\n      this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n\n\n    _createClass(ReadableStreamDefaultReader, [{\n      key: \"closed\",\n      get: function get() {\n        if (!IsReadableStreamDefaultReader(this)) {\n          return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n\n        return this._closedPromise;\n      }\n      /**\n       * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStreamDefaultReader(this)) {\n          return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n\n        if (this._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('cancel'));\n        }\n\n        return ReadableStreamReaderGenericCancel(this, reason);\n      }\n      /**\n       * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n       *\n       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n       */\n\n    }, {\n      key: \"read\",\n      value: function read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n          return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n\n        if (this._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('read from'));\n        }\n\n        var resolvePromise;\n        var rejectPromise;\n        var promise = newPromise(function (resolve, reject) {\n          resolvePromise = resolve;\n          rejectPromise = reject;\n        });\n        var readRequest = {\n          _chunkSteps: function _chunkSteps(chunk) {\n            return resolvePromise({\n              value: chunk,\n              done: false\n            });\n          },\n          _closeSteps: function _closeSteps() {\n            return resolvePromise({\n              value: undefined,\n              done: true\n            });\n          },\n          _errorSteps: function _errorSteps(e) {\n            return rejectPromise(e);\n          }\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n      }\n      /**\n       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n       * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n       * from now on; otherwise, the reader will appear closed.\n       *\n       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n       * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n       * do so will throw a `TypeError` and leave the reader locked to the stream.\n       */\n\n    }, {\n      key: \"releaseLock\",\n      value: function releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n          throw defaultReaderBrandCheckException('releaseLock');\n        }\n\n        if (this._ownerReadableStream === undefined) {\n          return;\n        }\n\n        if (this._readRequests.length > 0) {\n          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n\n        ReadableStreamReaderGenericRelease(this);\n      }\n    }]);\n\n    return ReadableStreamDefaultReader;\n  }();\n\n  Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: {\n      enumerable: true\n    },\n    read: {\n      enumerable: true\n    },\n    releaseLock: {\n      enumerable: true\n    },\n    closed: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableStreamDefaultReader',\n      configurable: true\n    });\n  } // Abstract operations for the readers.\n\n\n  function IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n      return false;\n    }\n\n    return x instanceof ReadableStreamDefaultReader;\n  }\n\n  function ReadableStreamDefaultReaderRead(reader, readRequest) {\n    var stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n\n    if (stream._state === 'closed') {\n      readRequest._closeSteps();\n    } else if (stream._state === 'errored') {\n      readRequest._errorSteps(stream._storedError);\n    } else {\n      stream._readableStreamController[PullSteps](readRequest);\n    }\n  } // Helper functions for the ReadableStreamDefaultReader.\n\n\n  function defaultReaderBrandCheckException(name) {\n    return new TypeError(\"ReadableStreamDefaultReader.prototype.\".concat(name, \" can only be used on a ReadableStreamDefaultReader\"));\n  } /// <reference lib=\"es2018.asynciterable\" />\n\n  /* eslint-disable @typescript-eslint/no-empty-function */\n\n\n  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf( /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }))).prototype); /// <reference lib=\"es2018.asynciterable\" />\n\n  var ReadableStreamAsyncIteratorImpl = /*#__PURE__*/function () {\n    function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {\n      _classCallCheck(this, ReadableStreamAsyncIteratorImpl);\n\n      this._ongoingPromise = undefined;\n      this._isFinished = false;\n      this._reader = reader;\n      this._preventCancel = preventCancel;\n    }\n\n    _createClass(ReadableStreamAsyncIteratorImpl, [{\n      key: \"next\",\n      value: function next() {\n        var _this = this;\n\n        var nextSteps = function nextSteps() {\n          return _this._nextSteps();\n        };\n\n        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n        return this._ongoingPromise;\n      }\n    }, {\n      key: \"return\",\n      value: function _return(value) {\n        var _this2 = this;\n\n        var returnSteps = function returnSteps() {\n          return _this2._returnSteps(value);\n        };\n\n        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n      }\n    }, {\n      key: \"_nextSteps\",\n      value: function _nextSteps() {\n        var _this3 = this;\n\n        if (this._isFinished) {\n          return Promise.resolve({\n            value: undefined,\n            done: true\n          });\n        }\n\n        var reader = this._reader;\n\n        if (reader._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('iterate'));\n        }\n\n        var resolvePromise;\n        var rejectPromise;\n        var promise = newPromise(function (resolve, reject) {\n          resolvePromise = resolve;\n          rejectPromise = reject;\n        });\n        var readRequest = {\n          _chunkSteps: function _chunkSteps(chunk) {\n            _this3._ongoingPromise = undefined; // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n            // FIXME Is this a bug in the specification, or in the test?\n\n            queueMicrotask(function () {\n              return resolvePromise({\n                value: chunk,\n                done: false\n              });\n            });\n          },\n          _closeSteps: function _closeSteps() {\n            _this3._ongoingPromise = undefined;\n            _this3._isFinished = true;\n            ReadableStreamReaderGenericRelease(reader);\n            resolvePromise({\n              value: undefined,\n              done: true\n            });\n          },\n          _errorSteps: function _errorSteps(reason) {\n            _this3._ongoingPromise = undefined;\n            _this3._isFinished = true;\n            ReadableStreamReaderGenericRelease(reader);\n            rejectPromise(reason);\n          }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n      }\n    }, {\n      key: \"_returnSteps\",\n      value: function _returnSteps(value) {\n        if (this._isFinished) {\n          return Promise.resolve({\n            value: value,\n            done: true\n          });\n        }\n\n        this._isFinished = true;\n        var reader = this._reader;\n\n        if (reader._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n\n        if (!this._preventCancel) {\n          var result = ReadableStreamReaderGenericCancel(reader, value);\n          ReadableStreamReaderGenericRelease(reader);\n          return transformPromiseWith(result, function () {\n            return {\n              value: value,\n              done: true\n            };\n          });\n        }\n\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({\n          value: value,\n          done: true\n        });\n      }\n    }]);\n\n    return ReadableStreamAsyncIteratorImpl;\n  }();\n\n  var ReadableStreamAsyncIteratorPrototype = {\n    next: function next() {\n      if (!IsReadableStreamAsyncIterator(this)) {\n        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n      }\n\n      return this._asyncIteratorImpl.next();\n    },\n    return: function _return(value) {\n      if (!IsReadableStreamAsyncIterator(this)) {\n        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n      }\n\n      return this._asyncIteratorImpl.return(value);\n    }\n  };\n\n  if (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n  } // Abstract operations for the ReadableStream.\n\n\n  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    var reader = AcquireReadableStreamDefaultReader(stream);\n    var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n  }\n\n  function IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n      return false;\n    }\n\n    try {\n      // noinspection SuspiciousTypeOfGuard\n      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n    } catch (_a) {\n      return false;\n    }\n  } // Helper functions for the ReadableStream.\n\n\n  function streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(\"ReadableStreamAsyncIterator.\".concat(name, \" can only be used on a ReadableSteamAsyncIterator\"));\n  } /// <reference lib=\"es2015.core\" />\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n\n\n  var NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n  };\n\n  function CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n  }\n\n  function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n  } // Not implemented correctly\n\n\n  function TransferArrayBuffer(O) {\n    return O;\n  } // Not implemented correctly\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  function IsDetachedBuffer(O) {\n    return false;\n  }\n\n  function ArrayBufferSlice(buffer, begin, end) {\n    // ArrayBuffer.prototype.slice is not available on IE10\n    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n    if (buffer.slice) {\n      return buffer.slice(begin, end);\n    }\n\n    var length = end - begin;\n    var slice = new ArrayBuffer(length);\n    CopyDataBlockBytes(slice, 0, buffer, begin, length);\n    return slice;\n  }\n\n  function IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n      return false;\n    }\n\n    if (NumberIsNaN(v)) {\n      return false;\n    }\n\n    if (v < 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function CloneAsUint8Array(O) {\n    var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n    return new Uint8Array(buffer);\n  }\n\n  function DequeueValue(container) {\n    var pair = container._queue.shift();\n\n    container._queueTotalSize -= pair.size;\n\n    if (container._queueTotalSize < 0) {\n      container._queueTotalSize = 0;\n    }\n\n    return pair.value;\n  }\n\n  function EnqueueValueWithSize(container, value, size) {\n    if (!IsNonNegativeNumber(size) || size === Infinity) {\n      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n\n    container._queue.push({\n      value: value,\n      size: size\n    });\n\n    container._queueTotalSize += size;\n  }\n\n  function PeekQueueValue(container) {\n    var pair = container._queue.peek();\n\n    return pair.value;\n  }\n\n  function ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n  }\n  /**\n   * A pull-into request in a {@link ReadableByteStreamController}.\n   *\n   * @public\n   */\n\n\n  var ReadableStreamBYOBRequest = /*#__PURE__*/function () {\n    function ReadableStreamBYOBRequest() {\n      _classCallCheck(this, ReadableStreamBYOBRequest);\n\n      throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n\n\n    _createClass(ReadableStreamBYOBRequest, [{\n      key: \"view\",\n      get: function get() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n          throw byobRequestBrandCheckException('view');\n        }\n\n        return this._view;\n      }\n    }, {\n      key: \"respond\",\n      value: function respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n          throw byobRequestBrandCheckException('respond');\n        }\n\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n\n        if (this._associatedReadableByteStreamController === undefined) {\n          throw new TypeError('This BYOB request has been invalidated');\n        }\n\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n      }\n    }, {\n      key: \"respondWithNewView\",\n      value: function respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n          throw byobRequestBrandCheckException('respondWithNewView');\n        }\n\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n\n        if (!ArrayBuffer.isView(view)) {\n          throw new TypeError('You can only respond with array buffer views');\n        }\n\n        if (this._associatedReadableByteStreamController === undefined) {\n          throw new TypeError('This BYOB request has been invalidated');\n        }\n\n        if (IsDetachedBuffer(view.buffer)) ;\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n      }\n    }]);\n\n    return ReadableStreamBYOBRequest;\n  }();\n\n  Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: {\n      enumerable: true\n    },\n    respondWithNewView: {\n      enumerable: true\n    },\n    view: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableStreamBYOBRequest',\n      configurable: true\n    });\n  }\n  /**\n   * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n   *\n   * @public\n   */\n\n\n  var ReadableByteStreamController = /*#__PURE__*/function () {\n    function ReadableByteStreamController() {\n      _classCallCheck(this, ReadableByteStreamController);\n\n      throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n\n\n    _createClass(ReadableByteStreamController, [{\n      key: \"byobRequest\",\n      get: function get() {\n        if (!IsReadableByteStreamController(this)) {\n          throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n\n        return ReadableByteStreamControllerGetBYOBRequest(this);\n      }\n      /**\n       * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n       * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n       */\n\n    }, {\n      key: \"desiredSize\",\n      get: function get() {\n        if (!IsReadableByteStreamController(this)) {\n          throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n\n        return ReadableByteStreamControllerGetDesiredSize(this);\n      }\n      /**\n       * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n       * the stream, but once those are read, the stream will become closed.\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!IsReadableByteStreamController(this)) {\n          throw byteStreamControllerBrandCheckException('close');\n        }\n\n        if (this._closeRequested) {\n          throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n\n        var state = this._controlledReadableByteStream._state;\n\n        if (state !== 'readable') {\n          throw new TypeError(\"The stream (in \".concat(state, \" state) is not in the readable state and cannot be closed\"));\n        }\n\n        ReadableByteStreamControllerClose(this);\n      }\n    }, {\n      key: \"enqueue\",\n      value: function enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n          throw byteStreamControllerBrandCheckException('enqueue');\n        }\n\n        assertRequiredArgument(chunk, 1, 'enqueue');\n\n        if (!ArrayBuffer.isView(chunk)) {\n          throw new TypeError('chunk must be an array buffer view');\n        }\n\n        if (chunk.byteLength === 0) {\n          throw new TypeError('chunk must have non-zero byteLength');\n        }\n\n        if (chunk.buffer.byteLength === 0) {\n          throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n        }\n\n        if (this._closeRequested) {\n          throw new TypeError('stream is closed or draining');\n        }\n\n        var state = this._controlledReadableByteStream._state;\n\n        if (state !== 'readable') {\n          throw new TypeError(\"The stream (in \".concat(state, \" state) is not in the readable state and cannot be enqueued to\"));\n        }\n\n        ReadableByteStreamControllerEnqueue(this, chunk);\n      }\n      /**\n       * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n       */\n\n    }, {\n      key: \"error\",\n      value: function error() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableByteStreamController(this)) {\n          throw byteStreamControllerBrandCheckException('error');\n        }\n\n        ReadableByteStreamControllerError(this, e);\n      }\n      /** @internal */\n\n    }, {\n      key: CancelSteps,\n      value: function value(reason) {\n        ReadableByteStreamControllerClearPendingPullIntos(this);\n        ResetQueue(this);\n\n        var result = this._cancelAlgorithm(reason);\n\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n      }\n      /** @internal */\n\n    }, {\n      key: PullSteps,\n      value: function value(readRequest) {\n        var stream = this._controlledReadableByteStream;\n\n        if (this._queueTotalSize > 0) {\n          var entry = this._queue.shift();\n\n          this._queueTotalSize -= entry.byteLength;\n          ReadableByteStreamControllerHandleQueueDrain(this);\n          var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n\n          readRequest._chunkSteps(view);\n\n          return;\n        }\n\n        var autoAllocateChunkSize = this._autoAllocateChunkSize;\n\n        if (autoAllocateChunkSize !== undefined) {\n          var buffer;\n\n          try {\n            buffer = new ArrayBuffer(autoAllocateChunkSize);\n          } catch (bufferE) {\n            readRequest._errorSteps(bufferE);\n\n            return;\n          }\n\n          var pullIntoDescriptor = {\n            buffer: buffer,\n            bufferByteLength: autoAllocateChunkSize,\n            byteOffset: 0,\n            byteLength: autoAllocateChunkSize,\n            bytesFilled: 0,\n            elementSize: 1,\n            viewConstructor: Uint8Array,\n            readerType: 'default'\n          };\n\n          this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n      }\n    }]);\n\n    return ReadableByteStreamController;\n  }();\n\n  Object.defineProperties(ReadableByteStreamController.prototype, {\n    close: {\n      enumerable: true\n    },\n    enqueue: {\n      enumerable: true\n    },\n    error: {\n      enumerable: true\n    },\n    byobRequest: {\n      enumerable: true\n    },\n    desiredSize: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableByteStreamController',\n      configurable: true\n    });\n  } // Abstract operations for the ReadableByteStreamController.\n\n\n  function IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n      return false;\n    }\n\n    return x instanceof ReadableByteStreamController;\n  }\n\n  function IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n      return false;\n    }\n\n    return x instanceof ReadableStreamBYOBRequest;\n  }\n\n  function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n\n    if (!shouldPull) {\n      return;\n    }\n\n    if (controller._pulling) {\n      controller._pullAgain = true;\n      return;\n    }\n\n    controller._pulling = true; // TODO: Test controller argument\n\n    var pullPromise = controller._pullAlgorithm();\n\n    uponPromise(pullPromise, function () {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n      }\n    }, function (e) {\n      ReadableByteStreamControllerError(controller, e);\n    });\n  }\n\n  function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n  }\n\n  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    var done = false;\n\n    if (stream._state === 'closed') {\n      done = true;\n    }\n\n    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n\n    if (pullIntoDescriptor.readerType === 'default') {\n      ReadableStreamFulfillReadRequest(stream, filledView, done);\n    } else {\n      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n  }\n\n  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    var bytesFilled = pullIntoDescriptor.bytesFilled;\n    var elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n  }\n\n  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({\n      buffer: buffer,\n      byteOffset: byteOffset,\n      byteLength: byteLength\n    });\n\n    controller._queueTotalSize += byteLength;\n  }\n\n  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    var elementSize = pullIntoDescriptor.elementSize;\n    var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    var totalBytesToCopyRemaining = maxBytesToCopy;\n    var ready = false;\n\n    if (maxAlignedBytes > currentAlignedBytes) {\n      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n      ready = true;\n    }\n\n    var queue = controller._queue;\n\n    while (totalBytesToCopyRemaining > 0) {\n      var headOfQueue = queue.peek();\n      var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n      var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n\n      if (headOfQueue.byteLength === bytesToCopy) {\n        queue.shift();\n      } else {\n        headOfQueue.byteOffset += bytesToCopy;\n        headOfQueue.byteLength -= bytesToCopy;\n      }\n\n      controller._queueTotalSize -= bytesToCopy;\n      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n      totalBytesToCopyRemaining -= bytesToCopy;\n    }\n\n    return ready;\n  }\n\n  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    pullIntoDescriptor.bytesFilled += size;\n  }\n\n  function ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n      ReadableByteStreamControllerClearAlgorithms(controller);\n      ReadableStreamClose(controller._controlledReadableByteStream);\n    } else {\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n  }\n\n  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n      return;\n    }\n\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n  }\n\n  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n      if (controller._queueTotalSize === 0) {\n        return;\n      }\n\n      var pullIntoDescriptor = controller._pendingPullIntos.peek();\n\n      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n      }\n    }\n  }\n\n  function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    var stream = controller._controlledReadableByteStream;\n    var elementSize = 1;\n\n    if (view.constructor !== DataView) {\n      elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n\n    var ctor = view.constructor; // try {\n\n    var buffer = TransferArrayBuffer(view.buffer); // } catch (e) {\n    //   readIntoRequest._errorSteps(e);\n    //   return;\n    // }\n\n    var pullIntoDescriptor = {\n      buffer: buffer,\n      bufferByteLength: buffer.byteLength,\n      byteOffset: view.byteOffset,\n      byteLength: view.byteLength,\n      bytesFilled: 0,\n      elementSize: elementSize,\n      viewConstructor: ctor,\n      readerType: 'byob'\n    };\n\n    if (controller._pendingPullIntos.length > 0) {\n      controller._pendingPullIntos.push(pullIntoDescriptor); // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n      // - No change happens on desiredSize\n      // - The source has already been notified of that there's at least 1 pending read(view)\n\n\n      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n      return;\n    }\n\n    if (stream._state === 'closed') {\n      var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n\n      readIntoRequest._closeSteps(emptyView);\n\n      return;\n    }\n\n    if (controller._queueTotalSize > 0) {\n      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        ReadableByteStreamControllerHandleQueueDrain(controller);\n\n        readIntoRequest._chunkSteps(filledView);\n\n        return;\n      }\n\n      if (controller._closeRequested) {\n        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n        ReadableByteStreamControllerError(controller, e);\n\n        readIntoRequest._errorSteps(e);\n\n        return;\n      }\n    }\n\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n\n  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    var stream = controller._controlledReadableByteStream;\n\n    if (ReadableStreamHasBYOBReader(stream)) {\n      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n      }\n    }\n  }\n\n  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n      return;\n    }\n\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n\n    if (remainderSize > 0) {\n      var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n      var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  }\n\n  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    var firstDescriptor = controller._pendingPullIntos.peek();\n\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    var state = controller._controlledReadableByteStream._state;\n\n    if (state === 'closed') {\n      ReadableByteStreamControllerRespondInClosedState(controller);\n    } else {\n      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n\n  function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    var descriptor = controller._pendingPullIntos.shift();\n\n    return descriptor;\n  }\n\n  function ReadableByteStreamControllerShouldCallPull(controller) {\n    var stream = controller._controlledReadableByteStream;\n\n    if (stream._state !== 'readable') {\n      return false;\n    }\n\n    if (controller._closeRequested) {\n      return false;\n    }\n\n    if (!controller._started) {\n      return false;\n    }\n\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n      return true;\n    }\n\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n      return true;\n    }\n\n    var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n\n    if (desiredSize > 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n  } // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n\n\n  function ReadableByteStreamControllerClose(controller) {\n    var stream = controller._controlledReadableByteStream;\n\n    if (controller._closeRequested || stream._state !== 'readable') {\n      return;\n    }\n\n    if (controller._queueTotalSize > 0) {\n      controller._closeRequested = true;\n      return;\n    }\n\n    if (controller._pendingPullIntos.length > 0) {\n      var firstPendingPullInto = controller._pendingPullIntos.peek();\n\n      if (firstPendingPullInto.bytesFilled > 0) {\n        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n        ReadableByteStreamControllerError(controller, e);\n        throw e;\n      }\n    }\n\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n  }\n\n  function ReadableByteStreamControllerEnqueue(controller, chunk) {\n    var stream = controller._controlledReadableByteStream;\n\n    if (controller._closeRequested || stream._state !== 'readable') {\n      return;\n    }\n\n    var buffer = chunk.buffer;\n    var byteOffset = chunk.byteOffset;\n    var byteLength = chunk.byteLength;\n    var transferredBuffer = TransferArrayBuffer(buffer);\n\n    if (controller._pendingPullIntos.length > 0) {\n      var firstPendingPullInto = controller._pendingPullIntos.peek();\n\n      if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;\n      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n    }\n\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n\n    if (ReadableStreamHasDefaultReader(stream)) {\n      if (ReadableStreamGetNumReadRequests(stream) === 0) {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n      } else {\n        if (controller._pendingPullIntos.length > 0) {\n          ReadableByteStreamControllerShiftPendingPullInto(controller);\n        }\n\n        var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n        ReadableStreamFulfillReadRequest(stream, transferredView, false);\n      }\n    } else if (ReadableStreamHasBYOBReader(stream)) {\n      // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    } else {\n      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n\n  function ReadableByteStreamControllerError(controller, e) {\n    var stream = controller._controlledReadableByteStream;\n\n    if (stream._state !== 'readable') {\n      return;\n    }\n\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n  }\n\n  function ReadableByteStreamControllerGetBYOBRequest(controller) {\n    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n      var firstDescriptor = controller._pendingPullIntos.peek();\n\n      var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n      var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n      SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n      controller._byobRequest = byobRequest;\n    }\n\n    return controller._byobRequest;\n  }\n\n  function ReadableByteStreamControllerGetDesiredSize(controller) {\n    var state = controller._controlledReadableByteStream._state;\n\n    if (state === 'errored') {\n      return null;\n    }\n\n    if (state === 'closed') {\n      return 0;\n    }\n\n    return controller._strategyHWM - controller._queueTotalSize;\n  }\n\n  function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    var firstDescriptor = controller._pendingPullIntos.peek();\n\n    var state = controller._controlledReadableByteStream._state;\n\n    if (state === 'closed') {\n      if (bytesWritten !== 0) {\n        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n      }\n    } else {\n      if (bytesWritten === 0) {\n        throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');\n      }\n\n      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n      }\n    }\n\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n  }\n\n  function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    var firstDescriptor = controller._pendingPullIntos.peek();\n\n    var state = controller._controlledReadableByteStream._state;\n\n    if (state === 'closed') {\n      if (view.byteLength !== 0) {\n        throw new TypeError('The view\\'s length must be 0 when calling respondWithNewView() on a closed stream');\n      }\n    } else {\n      if (view.byteLength === 0) {\n        throw new TypeError('The view\\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');\n      }\n    }\n\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n      throw new RangeError('The region specified by view does not match byobRequest');\n    }\n\n    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n      throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n\n    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n      throw new RangeError('The region specified by view is larger than byobRequest');\n    }\n\n    var viewByteLength = view.byteLength;\n    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n  }\n\n  function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    var startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), function () {\n      controller._started = true;\n      ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, function (r) {\n      ReadableByteStreamControllerError(controller, r);\n    });\n  }\n\n  function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    var controller = Object.create(ReadableByteStreamController.prototype);\n\n    var startAlgorithm = function startAlgorithm() {\n      return undefined;\n    };\n\n    var pullAlgorithm = function pullAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    var cancelAlgorithm = function cancelAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    if (underlyingByteSource.start !== undefined) {\n      startAlgorithm = function startAlgorithm() {\n        return underlyingByteSource.start(controller);\n      };\n    }\n\n    if (underlyingByteSource.pull !== undefined) {\n      pullAlgorithm = function pullAlgorithm() {\n        return underlyingByteSource.pull(controller);\n      };\n    }\n\n    if (underlyingByteSource.cancel !== undefined) {\n      cancelAlgorithm = function cancelAlgorithm(reason) {\n        return underlyingByteSource.cancel(reason);\n      };\n    }\n\n    var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n\n    if (autoAllocateChunkSize === 0) {\n      throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n  }\n\n  function SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n  } // Helper functions for the ReadableStreamBYOBRequest.\n\n\n  function byobRequestBrandCheckException(name) {\n    return new TypeError(\"ReadableStreamBYOBRequest.prototype.\".concat(name, \" can only be used on a ReadableStreamBYOBRequest\"));\n  } // Helper functions for the ReadableByteStreamController.\n\n\n  function byteStreamControllerBrandCheckException(name) {\n    return new TypeError(\"ReadableByteStreamController.prototype.\".concat(name, \" can only be used on a ReadableByteStreamController\"));\n  } // Abstract operations for the ReadableStream.\n\n\n  function AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n  } // ReadableStream API exposed for controllers.\n\n\n  function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n  }\n\n  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    var reader = stream._reader;\n\n    var readIntoRequest = reader._readIntoRequests.shift();\n\n    if (done) {\n      readIntoRequest._closeSteps(chunk);\n    } else {\n      readIntoRequest._chunkSteps(chunk);\n    }\n  }\n\n  function ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n  }\n\n  function ReadableStreamHasBYOBReader(stream) {\n    var reader = stream._reader;\n\n    if (reader === undefined) {\n      return false;\n    }\n\n    if (!IsReadableStreamBYOBReader(reader)) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * A BYOB reader vended by a {@link ReadableStream}.\n   *\n   * @public\n   */\n\n\n  var ReadableStreamBYOBReader = /*#__PURE__*/function () {\n    function ReadableStreamBYOBReader(stream) {\n      _classCallCheck(this, ReadableStreamBYOBReader);\n\n      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n      assertReadableStream(stream, 'First parameter');\n\n      if (IsReadableStreamLocked(stream)) {\n        throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n      }\n\n      if (!IsReadableByteStreamController(stream._readableStreamController)) {\n        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\n      }\n\n      ReadableStreamReaderGenericInitialize(this, stream);\n      this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n\n\n    _createClass(ReadableStreamBYOBReader, [{\n      key: \"closed\",\n      get: function get() {\n        if (!IsReadableStreamBYOBReader(this)) {\n          return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n\n        return this._closedPromise;\n      }\n      /**\n       * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStreamBYOBReader(this)) {\n          return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n\n        if (this._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('cancel'));\n        }\n\n        return ReadableStreamReaderGenericCancel(this, reason);\n      }\n      /**\n       * Attempts to reads bytes into view, and returns a promise resolved with the result.\n       *\n       * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n       */\n\n    }, {\n      key: \"read\",\n      value: function read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n          return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n\n        if (!ArrayBuffer.isView(view)) {\n          return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n\n        if (view.byteLength === 0) {\n          return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n\n        if (view.buffer.byteLength === 0) {\n          return promiseRejectedWith(new TypeError(\"view's buffer must have non-zero byteLength\"));\n        }\n\n        if (IsDetachedBuffer(view.buffer)) ;\n\n        if (this._ownerReadableStream === undefined) {\n          return promiseRejectedWith(readerLockException('read from'));\n        }\n\n        var resolvePromise;\n        var rejectPromise;\n        var promise = newPromise(function (resolve, reject) {\n          resolvePromise = resolve;\n          rejectPromise = reject;\n        });\n        var readIntoRequest = {\n          _chunkSteps: function _chunkSteps(chunk) {\n            return resolvePromise({\n              value: chunk,\n              done: false\n            });\n          },\n          _closeSteps: function _closeSteps(chunk) {\n            return resolvePromise({\n              value: chunk,\n              done: true\n            });\n          },\n          _errorSteps: function _errorSteps(e) {\n            return rejectPromise(e);\n          }\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n      }\n      /**\n       * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n       * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n       * from now on; otherwise, the reader will appear closed.\n       *\n       * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n       * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n       * do so will throw a `TypeError` and leave the reader locked to the stream.\n       */\n\n    }, {\n      key: \"releaseLock\",\n      value: function releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n          throw byobReaderBrandCheckException('releaseLock');\n        }\n\n        if (this._ownerReadableStream === undefined) {\n          return;\n        }\n\n        if (this._readIntoRequests.length > 0) {\n          throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n\n        ReadableStreamReaderGenericRelease(this);\n      }\n    }]);\n\n    return ReadableStreamBYOBReader;\n  }();\n\n  Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: {\n      enumerable: true\n    },\n    read: {\n      enumerable: true\n    },\n    releaseLock: {\n      enumerable: true\n    },\n    closed: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableStreamBYOBReader',\n      configurable: true\n    });\n  } // Abstract operations for the readers.\n\n\n  function IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n      return false;\n    }\n\n    return x instanceof ReadableStreamBYOBReader;\n  }\n\n  function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    var stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n\n    if (stream._state === 'errored') {\n      readIntoRequest._errorSteps(stream._storedError);\n    } else {\n      ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n  } // Helper functions for the ReadableStreamBYOBReader.\n\n\n  function byobReaderBrandCheckException(name) {\n    return new TypeError(\"ReadableStreamBYOBReader.prototype.\".concat(name, \" can only be used on a ReadableStreamBYOBReader\"));\n  }\n\n  function ExtractHighWaterMark(strategy, defaultHWM) {\n    var highWaterMark = strategy.highWaterMark;\n\n    if (highWaterMark === undefined) {\n      return defaultHWM;\n    }\n\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n      throw new RangeError('Invalid highWaterMark');\n    }\n\n    return highWaterMark;\n  }\n\n  function ExtractSizeAlgorithm(strategy) {\n    var size = strategy.size;\n\n    if (!size) {\n      return function () {\n        return 1;\n      };\n    }\n\n    return size;\n  }\n\n  function convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    var size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n      highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n      size: size === undefined ? undefined : convertQueuingStrategySize(size, \"\".concat(context, \" has member 'size' that\"))\n    };\n  }\n\n  function convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return function (chunk) {\n      return convertUnrestrictedDouble(fn(chunk));\n    };\n  }\n\n  function convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    var abort = original === null || original === void 0 ? void 0 : original.abort;\n    var close = original === null || original === void 0 ? void 0 : original.close;\n    var start = original === null || original === void 0 ? void 0 : original.start;\n    var type = original === null || original === void 0 ? void 0 : original.type;\n    var write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, \"\".concat(context, \" has member 'abort' that\")),\n      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, \"\".concat(context, \" has member 'close' that\")),\n      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, \"\".concat(context, \" has member 'start' that\")),\n      write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, \"\".concat(context, \" has member 'write' that\")),\n      type: type\n    };\n  }\n\n  function convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (reason) {\n      return promiseCall(fn, original, [reason]);\n    };\n  }\n\n  function convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function () {\n      return promiseCall(fn, original, []);\n    };\n  }\n\n  function convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (controller) {\n      return reflectCall(fn, original, [controller]);\n    };\n  }\n\n  function convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (chunk, controller) {\n      return promiseCall(fn, original, [chunk, controller]);\n    };\n  }\n\n  function assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n      throw new TypeError(\"\".concat(context, \" is not a WritableStream.\"));\n    }\n  }\n\n  function isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    try {\n      return typeof value.aborted === 'boolean';\n    } catch (_a) {\n      // AbortSignal.prototype.aborted throws if its brand check fails\n      return false;\n    }\n  }\n\n  var supportsAbortController = typeof AbortController === 'function';\n  /**\n   * Construct a new AbortController, if supported by the platform.\n   *\n   * @internal\n   */\n\n  function createAbortController() {\n    if (supportsAbortController) {\n      return new AbortController();\n    }\n\n    return undefined;\n  }\n  /**\n   * A writable stream represents a destination for data, into which you can write.\n   *\n   * @public\n   */\n\n\n  var WritableStream = /*#__PURE__*/function () {\n    function WritableStream() {\n      var rawUnderlyingSink = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rawStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, WritableStream);\n\n      if (rawUnderlyingSink === undefined) {\n        rawUnderlyingSink = null;\n      } else {\n        assertObject(rawUnderlyingSink, 'First parameter');\n      }\n\n      var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n      var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n      InitializeWritableStream(this);\n      var type = underlyingSink.type;\n\n      if (type !== undefined) {\n        throw new RangeError('Invalid type is specified');\n      }\n\n      var sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n      var highWaterMark = ExtractHighWaterMark(strategy, 1);\n      SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n\n\n    _createClass(WritableStream, [{\n      key: \"locked\",\n      get: function get() {\n        if (!IsWritableStream(this)) {\n          throw streamBrandCheckException$2('locked');\n        }\n\n        return IsWritableStreamLocked(this);\n      }\n      /**\n       * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n       * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n       * mechanism of the underlying sink.\n       *\n       * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n       * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n       * the stream) if the stream is currently locked.\n       */\n\n    }, {\n      key: \"abort\",\n      value: function abort() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsWritableStream(this)) {\n          return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n\n        if (IsWritableStreamLocked(this)) {\n          return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n\n        return WritableStreamAbort(this, reason);\n      }\n      /**\n       * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n       * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n       *\n       * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n       * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n       * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!IsWritableStream(this)) {\n          return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n\n        if (IsWritableStreamLocked(this)) {\n          return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n          return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n\n        return WritableStreamClose(this);\n      }\n      /**\n       * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n       * is locked, no other writer can be acquired until this one is released.\n       *\n       * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n       * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n       * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n       */\n\n    }, {\n      key: \"getWriter\",\n      value: function getWriter() {\n        if (!IsWritableStream(this)) {\n          throw streamBrandCheckException$2('getWriter');\n        }\n\n        return AcquireWritableStreamDefaultWriter(this);\n      }\n    }]);\n\n    return WritableStream;\n  }();\n\n  Object.defineProperties(WritableStream.prototype, {\n    abort: {\n      enumerable: true\n    },\n    close: {\n      enumerable: true\n    },\n    getWriter: {\n      enumerable: true\n    },\n    locked: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n      value: 'WritableStream',\n      configurable: true\n    });\n  } // Abstract operations for the WritableStream.\n\n\n  function AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n  } // Throws if and only if startAlgorithm throws.\n\n\n  function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm) {\n    var highWaterMark = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n    var sizeAlgorithm = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function () {\n      return 1;\n    };\n    var stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    var controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n  }\n\n  function InitializeWritableStream(stream) {\n    stream._state = 'writable'; // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n\n    stream._storedError = undefined;\n    stream._writer = undefined; // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n\n    stream._writableStreamController = undefined; // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n\n    stream._writeRequests = new SimpleQueue(); // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n\n    stream._inFlightWriteRequest = undefined; // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n\n    stream._closeRequest = undefined; // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n\n    stream._inFlightCloseRequest = undefined; // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n\n    stream._pendingAbortRequest = undefined; // The backpressure signal set by the controller.\n\n    stream._backpressure = false;\n  }\n\n  function IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n      return false;\n    }\n\n    return x instanceof WritableStream;\n  }\n\n  function IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function WritableStreamAbort(stream, reason) {\n    var _a;\n\n    if (stream._state === 'closed' || stream._state === 'errored') {\n      return promiseResolvedWith(undefined);\n    }\n\n    stream._writableStreamController._abortReason = reason;\n    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(); // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n    // but it doesn't know that signaling abort runs author code that might have changed the state.\n    // Widen the type again by casting to WritableStreamState.\n\n    var state = stream._state;\n\n    if (state === 'closed' || state === 'errored') {\n      return promiseResolvedWith(undefined);\n    }\n\n    if (stream._pendingAbortRequest !== undefined) {\n      return stream._pendingAbortRequest._promise;\n    }\n\n    var wasAlreadyErroring = false;\n\n    if (state === 'erroring') {\n      wasAlreadyErroring = true; // reason will not be used, so don't keep a reference to it.\n\n      reason = undefined;\n    }\n\n    var promise = newPromise(function (resolve, reject) {\n      stream._pendingAbortRequest = {\n        _promise: undefined,\n        _resolve: resolve,\n        _reject: reject,\n        _reason: reason,\n        _wasAlreadyErroring: wasAlreadyErroring\n      };\n    });\n    stream._pendingAbortRequest._promise = promise;\n\n    if (!wasAlreadyErroring) {\n      WritableStreamStartErroring(stream, reason);\n    }\n\n    return promise;\n  }\n\n  function WritableStreamClose(stream) {\n    var state = stream._state;\n\n    if (state === 'closed' || state === 'errored') {\n      return promiseRejectedWith(new TypeError(\"The stream (in \".concat(state, \" state) is not in the writable state and cannot be closed\")));\n    }\n\n    var promise = newPromise(function (resolve, reject) {\n      var closeRequest = {\n        _resolve: resolve,\n        _reject: reject\n      };\n      stream._closeRequest = closeRequest;\n    });\n    var writer = stream._writer;\n\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n      defaultWriterReadyPromiseResolve(writer);\n    }\n\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n  } // WritableStream API exposed for controllers.\n\n\n  function WritableStreamAddWriteRequest(stream) {\n    var promise = newPromise(function (resolve, reject) {\n      var writeRequest = {\n        _resolve: resolve,\n        _reject: reject\n      };\n\n      stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n  }\n\n  function WritableStreamDealWithRejection(stream, error) {\n    var state = stream._state;\n\n    if (state === 'writable') {\n      WritableStreamStartErroring(stream, error);\n      return;\n    }\n\n    WritableStreamFinishErroring(stream);\n  }\n\n  function WritableStreamStartErroring(stream, reason) {\n    var controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    var writer = stream._writer;\n\n    if (writer !== undefined) {\n      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n      WritableStreamFinishErroring(stream);\n    }\n  }\n\n  function WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n\n    stream._writableStreamController[ErrorSteps]();\n\n    var storedError = stream._storedError;\n\n    stream._writeRequests.forEach(function (writeRequest) {\n      writeRequest._reject(storedError);\n    });\n\n    stream._writeRequests = new SimpleQueue();\n\n    if (stream._pendingAbortRequest === undefined) {\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return;\n    }\n\n    var abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n\n    if (abortRequest._wasAlreadyErroring) {\n      abortRequest._reject(storedError);\n\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n      return;\n    }\n\n    var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n\n    uponPromise(promise, function () {\n      abortRequest._resolve();\n\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, function (reason) {\n      abortRequest._reject(reason);\n\n      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n  }\n\n  function WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n\n    stream._inFlightWriteRequest = undefined;\n  }\n\n  function WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n  }\n\n  function WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n\n    stream._inFlightCloseRequest = undefined;\n    var state = stream._state;\n\n    if (state === 'erroring') {\n      // The error was too late to do anything, so it is ignored.\n      stream._storedError = undefined;\n\n      if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._resolve();\n\n        stream._pendingAbortRequest = undefined;\n      }\n    }\n\n    stream._state = 'closed';\n    var writer = stream._writer;\n\n    if (writer !== undefined) {\n      defaultWriterClosedPromiseResolve(writer);\n    }\n  }\n\n  function WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n\n    stream._inFlightCloseRequest = undefined; // Never execute sink abort() after sink close().\n\n    if (stream._pendingAbortRequest !== undefined) {\n      stream._pendingAbortRequest._reject(error);\n\n      stream._pendingAbortRequest = undefined;\n    }\n\n    WritableStreamDealWithRejection(stream, error);\n  } // TODO(ricea): Fix alphabetical order.\n\n\n  function WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n  }\n\n  function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n  }\n\n  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n      stream._closeRequest._reject(stream._storedError);\n\n      stream._closeRequest = undefined;\n    }\n\n    var writer = stream._writer;\n\n    if (writer !== undefined) {\n      defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n  }\n\n  function WritableStreamUpdateBackpressure(stream, backpressure) {\n    var writer = stream._writer;\n\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n      if (backpressure) {\n        defaultWriterReadyPromiseReset(writer);\n      } else {\n        defaultWriterReadyPromiseResolve(writer);\n      }\n    }\n\n    stream._backpressure = backpressure;\n  }\n  /**\n   * A default writer vended by a {@link WritableStream}.\n   *\n   * @public\n   */\n\n\n  var WritableStreamDefaultWriter = /*#__PURE__*/function () {\n    function WritableStreamDefaultWriter(stream) {\n      _classCallCheck(this, WritableStreamDefaultWriter);\n\n      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n      assertWritableStream(stream, 'First parameter');\n\n      if (IsWritableStreamLocked(stream)) {\n        throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n      }\n\n      this._ownerWritableStream = stream;\n      stream._writer = this;\n      var state = stream._state;\n\n      if (state === 'writable') {\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n          defaultWriterReadyPromiseInitialize(this);\n        } else {\n          defaultWriterReadyPromiseInitializeAsResolved(this);\n        }\n\n        defaultWriterClosedPromiseInitialize(this);\n      } else if (state === 'erroring') {\n        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n        defaultWriterClosedPromiseInitialize(this);\n      } else if (state === 'closed') {\n        defaultWriterReadyPromiseInitializeAsResolved(this);\n        defaultWriterClosedPromiseInitializeAsResolved(this);\n      } else {\n        var storedError = stream._storedError;\n        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n      }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n\n\n    _createClass(WritableStreamDefaultWriter, [{\n      key: \"closed\",\n      get: function get() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n          return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n\n        return this._closedPromise;\n      }\n      /**\n       * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n       * A producer can use this information to determine the right amount of data to write.\n       *\n       * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n       * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n       * the writers lock is released.\n       */\n\n    }, {\n      key: \"desiredSize\",\n      get: function get() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n          throw defaultWriterBrandCheckException('desiredSize');\n        }\n\n        if (this._ownerWritableStream === undefined) {\n          throw defaultWriterLockException('desiredSize');\n        }\n\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n      }\n      /**\n       * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n       * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n       * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n       *\n       * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n       * rejected.\n       */\n\n    }, {\n      key: \"ready\",\n      get: function get() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n          return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n\n        return this._readyPromise;\n      }\n      /**\n       * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n       */\n\n    }, {\n      key: \"abort\",\n      value: function abort() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsWritableStreamDefaultWriter(this)) {\n          return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n\n        if (this._ownerWritableStream === undefined) {\n          return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n\n        return WritableStreamDefaultWriterAbort(this, reason);\n      }\n      /**\n       * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n          return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n\n        var stream = this._ownerWritableStream;\n\n        if (stream === undefined) {\n          return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n          return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n\n        return WritableStreamDefaultWriterClose(this);\n      }\n      /**\n       * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n       * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n       * now on; otherwise, the writer will appear closed.\n       *\n       * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n       * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n       * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n       * other producers from writing in an interleaved manner.\n       */\n\n    }, {\n      key: \"releaseLock\",\n      value: function releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n          throw defaultWriterBrandCheckException('releaseLock');\n        }\n\n        var stream = this._ownerWritableStream;\n\n        if (stream === undefined) {\n          return;\n        }\n\n        WritableStreamDefaultWriterRelease(this);\n      }\n    }, {\n      key: \"write\",\n      value: function write() {\n        var chunk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsWritableStreamDefaultWriter(this)) {\n          return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n\n        if (this._ownerWritableStream === undefined) {\n          return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n\n        return WritableStreamDefaultWriterWrite(this, chunk);\n      }\n    }]);\n\n    return WritableStreamDefaultWriter;\n  }();\n\n  Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: {\n      enumerable: true\n    },\n    close: {\n      enumerable: true\n    },\n    releaseLock: {\n      enumerable: true\n    },\n    write: {\n      enumerable: true\n    },\n    closed: {\n      enumerable: true\n    },\n    desiredSize: {\n      enumerable: true\n    },\n    ready: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n      value: 'WritableStreamDefaultWriter',\n      configurable: true\n    });\n  } // Abstract operations for the WritableStreamDefaultWriter.\n\n\n  function IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n      return false;\n    }\n\n    return x instanceof WritableStreamDefaultWriter;\n  } // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n\n\n  function WritableStreamDefaultWriterAbort(writer, reason) {\n    var stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n  }\n\n  function WritableStreamDefaultWriterClose(writer) {\n    var stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n  }\n\n  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    var stream = writer._ownerWritableStream;\n    var state = stream._state;\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n      return promiseResolvedWith(undefined);\n    }\n\n    if (state === 'errored') {\n      return promiseRejectedWith(stream._storedError);\n    }\n\n    return WritableStreamDefaultWriterClose(writer);\n  }\n\n  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n      defaultWriterClosedPromiseReject(writer, error);\n    } else {\n      defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n  }\n\n  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n      defaultWriterReadyPromiseReject(writer, error);\n    } else {\n      defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n  }\n\n  function WritableStreamDefaultWriterGetDesiredSize(writer) {\n    var stream = writer._ownerWritableStream;\n    var state = stream._state;\n\n    if (state === 'errored' || state === 'erroring') {\n      return null;\n    }\n\n    if (state === 'closed') {\n      return 0;\n    }\n\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n  }\n\n  function WritableStreamDefaultWriterRelease(writer) {\n    var stream = writer._ownerWritableStream;\n    var releasedError = new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n  }\n\n  function WritableStreamDefaultWriterWrite(writer, chunk) {\n    var stream = writer._ownerWritableStream;\n    var controller = stream._writableStreamController;\n    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n\n    if (stream !== writer._ownerWritableStream) {\n      return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n\n    var state = stream._state;\n\n    if (state === 'errored') {\n      return promiseRejectedWith(stream._storedError);\n    }\n\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n      return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n\n    if (state === 'erroring') {\n      return promiseRejectedWith(stream._storedError);\n    }\n\n    var promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n  }\n\n  var closeSentinel = {};\n  /**\n   * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n   *\n   * @public\n   */\n\n  var WritableStreamDefaultController = /*#__PURE__*/function () {\n    function WritableStreamDefaultController() {\n      _classCallCheck(this, WritableStreamDefaultController);\n\n      throw new TypeError('Illegal constructor');\n    }\n    /**\n     * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n     *\n     * @deprecated\n     *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n     *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n     */\n\n\n    _createClass(WritableStreamDefaultController, [{\n      key: \"abortReason\",\n      get: function get() {\n        if (!IsWritableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$2('abortReason');\n        }\n\n        return this._abortReason;\n      }\n      /**\n       * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n       */\n\n    }, {\n      key: \"signal\",\n      get: function get() {\n        if (!IsWritableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$2('signal');\n        }\n\n        if (this._abortController === undefined) {\n          // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n          // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n          // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n          throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');\n        }\n\n        return this._abortController.signal;\n      }\n      /**\n       * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n       *\n       * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n       * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n       * normal lifecycle of interactions with the underlying sink.\n       */\n\n    }, {\n      key: \"error\",\n      value: function error() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsWritableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$2('error');\n        }\n\n        var state = this._controlledWritableStream._state;\n\n        if (state !== 'writable') {\n          // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n          // just treat it as a no-op.\n          return;\n        }\n\n        WritableStreamDefaultControllerError(this, e);\n      }\n      /** @internal */\n\n    }, {\n      key: AbortSteps,\n      value: function value(reason) {\n        var result = this._abortAlgorithm(reason);\n\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n      }\n      /** @internal */\n\n    }, {\n      key: ErrorSteps,\n      value: function value() {\n        ResetQueue(this);\n      }\n    }]);\n\n    return WritableStreamDefaultController;\n  }();\n\n  Object.defineProperties(WritableStreamDefaultController.prototype, {\n    abortReason: {\n      enumerable: true\n    },\n    signal: {\n      enumerable: true\n    },\n    error: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n      value: 'WritableStreamDefaultController',\n      configurable: true\n    });\n  } // Abstract operations implementing interface required by the WritableStream.\n\n\n  function IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n      return false;\n    }\n\n    return x instanceof WritableStreamDefaultController;\n  }\n\n  function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._abortReason = undefined;\n    controller._abortController = createAbortController();\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    var startResult = startAlgorithm();\n    var startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, function () {\n      controller._started = true;\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, function (r) {\n      controller._started = true;\n      WritableStreamDealWithRejection(stream, r);\n    });\n  }\n\n  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    var controller = Object.create(WritableStreamDefaultController.prototype);\n\n    var startAlgorithm = function startAlgorithm() {\n      return undefined;\n    };\n\n    var writeAlgorithm = function writeAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    var closeAlgorithm = function closeAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    var abortAlgorithm = function abortAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    if (underlyingSink.start !== undefined) {\n      startAlgorithm = function startAlgorithm() {\n        return underlyingSink.start(controller);\n      };\n    }\n\n    if (underlyingSink.write !== undefined) {\n      writeAlgorithm = function writeAlgorithm(chunk) {\n        return underlyingSink.write(chunk, controller);\n      };\n    }\n\n    if (underlyingSink.close !== undefined) {\n      closeAlgorithm = function closeAlgorithm() {\n        return underlyingSink.close();\n      };\n    }\n\n    if (underlyingSink.abort !== undefined) {\n      abortAlgorithm = function abortAlgorithm(reason) {\n        return underlyingSink.abort(reason);\n      };\n    }\n\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  } // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n\n\n  function WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n  }\n\n  function WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }\n\n  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n      return controller._strategySizeAlgorithm(chunk);\n    } catch (chunkSizeE) {\n      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n      return 1;\n    }\n  }\n\n  function WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n  }\n\n  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n      EnqueueValueWithSize(controller, chunk, chunkSize);\n    } catch (enqueueE) {\n      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n      return;\n    }\n\n    var stream = controller._controlledWritableStream;\n\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n      WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  } // Abstract operations for the WritableStreamDefaultController.\n\n\n  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    var stream = controller._controlledWritableStream;\n\n    if (!controller._started) {\n      return;\n    }\n\n    if (stream._inFlightWriteRequest !== undefined) {\n      return;\n    }\n\n    var state = stream._state;\n\n    if (state === 'erroring') {\n      WritableStreamFinishErroring(stream);\n      return;\n    }\n\n    if (controller._queue.length === 0) {\n      return;\n    }\n\n    var value = PeekQueueValue(controller);\n\n    if (value === closeSentinel) {\n      WritableStreamDefaultControllerProcessClose(controller);\n    } else {\n      WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n  }\n\n  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n      WritableStreamDefaultControllerError(controller, error);\n    }\n  }\n\n  function WritableStreamDefaultControllerProcessClose(controller) {\n    var stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n\n    var sinkClosePromise = controller._closeAlgorithm();\n\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, function () {\n      WritableStreamFinishInFlightClose(stream);\n    }, function (reason) {\n      WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n  }\n\n  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    var stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n\n    var sinkWritePromise = controller._writeAlgorithm(chunk);\n\n    uponPromise(sinkWritePromise, function () {\n      WritableStreamFinishInFlightWrite(stream);\n      var state = stream._state;\n      DequeueValue(controller);\n\n      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n      }\n\n      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, function (reason) {\n      if (stream._state === 'writable') {\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n      }\n\n      WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n  }\n\n  function WritableStreamDefaultControllerGetBackpressure(controller) {\n    var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n  } // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n\n\n  function WritableStreamDefaultControllerError(controller, error) {\n    var stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n  } // Helper functions for the WritableStream.\n\n\n  function streamBrandCheckException$2(name) {\n    return new TypeError(\"WritableStream.prototype.\".concat(name, \" can only be used on a WritableStream\"));\n  } // Helper functions for the WritableStreamDefaultController.\n\n\n  function defaultControllerBrandCheckException$2(name) {\n    return new TypeError(\"WritableStreamDefaultController.prototype.\".concat(name, \" can only be used on a WritableStreamDefaultController\"));\n  } // Helper functions for the WritableStreamDefaultWriter.\n\n\n  function defaultWriterBrandCheckException(name) {\n    return new TypeError(\"WritableStreamDefaultWriter.prototype.\".concat(name, \" can only be used on a WritableStreamDefaultWriter\"));\n  }\n\n  function defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n  }\n\n  function defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise(function (resolve, reject) {\n      writer._closedPromise_resolve = resolve;\n      writer._closedPromise_reject = reject;\n      writer._closedPromiseState = 'pending';\n    });\n  }\n\n  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n  }\n\n  function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n  }\n\n  function defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n      return;\n    }\n\n    setPromiseIsHandledToTrue(writer._closedPromise);\n\n    writer._closedPromise_reject(reason);\n\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n  }\n\n  function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n  }\n\n  function defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n      return;\n    }\n\n    writer._closedPromise_resolve(undefined);\n\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n  }\n\n  function defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise(function (resolve, reject) {\n      writer._readyPromise_resolve = resolve;\n      writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n  }\n\n  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n  }\n\n  function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n  }\n\n  function defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n      return;\n    }\n\n    setPromiseIsHandledToTrue(writer._readyPromise);\n\n    writer._readyPromise_reject(reason);\n\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n  }\n\n  function defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n  }\n\n  function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n  }\n\n  function defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n      return;\n    }\n\n    writer._readyPromise_resolve(undefined);\n\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n  } /// <reference lib=\"dom\" />\n\n\n  var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined; /// <reference types=\"node\" />\n\n  function isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n      return false;\n    }\n\n    try {\n      new ctor();\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  }\n\n  function createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    var ctor = function DOMException(message, name) {\n      this.message = message || '';\n      this.name = name || 'Error';\n\n      if (Error.captureStackTrace) {\n        Error.captureStackTrace(this, this.constructor);\n      }\n    };\n\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', {\n      value: ctor,\n      writable: true,\n      configurable: true\n    });\n    return ctor;\n  } // eslint-disable-next-line no-redeclare\n\n\n  var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\n  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    var reader = AcquireReadableStreamDefaultReader(source);\n    var writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    var shuttingDown = false; // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n\n    var currentWrite = promiseResolvedWith(undefined);\n    return newPromise(function (resolve, reject) {\n      var abortAlgorithm;\n\n      if (signal !== undefined) {\n        abortAlgorithm = function abortAlgorithm() {\n          var error = new DOMException$1('Aborted', 'AbortError');\n          var actions = [];\n\n          if (!preventAbort) {\n            actions.push(function () {\n              if (dest._state === 'writable') {\n                return WritableStreamAbort(dest, error);\n              }\n\n              return promiseResolvedWith(undefined);\n            });\n          }\n\n          if (!preventCancel) {\n            actions.push(function () {\n              if (source._state === 'readable') {\n                return ReadableStreamCancel(source, error);\n              }\n\n              return promiseResolvedWith(undefined);\n            });\n          }\n\n          shutdownWithAction(function () {\n            return Promise.all(actions.map(function (action) {\n              return action();\n            }));\n          }, true, error);\n        };\n\n        if (signal.aborted) {\n          abortAlgorithm();\n          return;\n        }\n\n        signal.addEventListener('abort', abortAlgorithm);\n      } // Using reader and writer, read all chunks from this and write them to dest\n      // - Backpressure must be enforced\n      // - Shutdown must stop all activity\n\n\n      function pipeLoop() {\n        return newPromise(function (resolveLoop, rejectLoop) {\n          function next(done) {\n            if (done) {\n              resolveLoop();\n            } else {\n              // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n              // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n              PerformPromiseThen(pipeStep(), next, rejectLoop);\n            }\n          }\n\n          next(false);\n        });\n      }\n\n      function pipeStep() {\n        if (shuttingDown) {\n          return promiseResolvedWith(true);\n        }\n\n        return PerformPromiseThen(writer._readyPromise, function () {\n          return newPromise(function (resolveRead, rejectRead) {\n            ReadableStreamDefaultReaderRead(reader, {\n              _chunkSteps: function _chunkSteps(chunk) {\n                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                resolveRead(false);\n              },\n              _closeSteps: function _closeSteps() {\n                return resolveRead(true);\n              },\n              _errorSteps: rejectRead\n            });\n          });\n        });\n      } // Errors must be propagated forward\n\n\n      isOrBecomesErrored(source, reader._closedPromise, function (storedError) {\n        if (!preventAbort) {\n          shutdownWithAction(function () {\n            return WritableStreamAbort(dest, storedError);\n          }, true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      }); // Errors must be propagated backward\n\n      isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\n        if (!preventCancel) {\n          shutdownWithAction(function () {\n            return ReadableStreamCancel(source, storedError);\n          }, true, storedError);\n        } else {\n          shutdown(true, storedError);\n        }\n      }); // Closing must be propagated forward\n\n      isOrBecomesClosed(source, reader._closedPromise, function () {\n        if (!preventClose) {\n          shutdownWithAction(function () {\n            return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);\n          });\n        } else {\n          shutdown();\n        }\n      }); // Closing must be propagated backward\n\n      if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n        var destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n\n        if (!preventCancel) {\n          shutdownWithAction(function () {\n            return ReadableStreamCancel(source, destClosed);\n          }, true, destClosed);\n        } else {\n          shutdown(true, destClosed);\n        }\n      }\n\n      setPromiseIsHandledToTrue(pipeLoop());\n\n      function waitForWritesToFinish() {\n        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n        // for that too.\n        var oldCurrentWrite = currentWrite;\n        return PerformPromiseThen(currentWrite, function () {\n          return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\n        });\n      }\n\n      function isOrBecomesErrored(stream, promise, action) {\n        if (stream._state === 'errored') {\n          action(stream._storedError);\n        } else {\n          uponRejection(promise, action);\n        }\n      }\n\n      function isOrBecomesClosed(stream, promise, action) {\n        if (stream._state === 'closed') {\n          action();\n        } else {\n          uponFulfillment(promise, action);\n        }\n      }\n\n      function shutdownWithAction(action, originalIsError, originalError) {\n        if (shuttingDown) {\n          return;\n        }\n\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n          uponFulfillment(waitForWritesToFinish(), doTheRest);\n        } else {\n          doTheRest();\n        }\n\n        function doTheRest() {\n          uponPromise(action(), function () {\n            return finalize(originalIsError, originalError);\n          }, function (newError) {\n            return finalize(true, newError);\n          });\n        }\n      }\n\n      function shutdown(isError, error) {\n        if (shuttingDown) {\n          return;\n        }\n\n        shuttingDown = true;\n\n        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n          uponFulfillment(waitForWritesToFinish(), function () {\n            return finalize(isError, error);\n          });\n        } else {\n          finalize(isError, error);\n        }\n      }\n\n      function finalize(isError, error) {\n        WritableStreamDefaultWriterRelease(writer);\n        ReadableStreamReaderGenericRelease(reader);\n\n        if (signal !== undefined) {\n          signal.removeEventListener('abort', abortAlgorithm);\n        }\n\n        if (isError) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  }\n  /**\n   * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n   *\n   * @public\n   */\n\n\n  var ReadableStreamDefaultController = /*#__PURE__*/function () {\n    function ReadableStreamDefaultController() {\n      _classCallCheck(this, ReadableStreamDefaultController);\n\n      throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n\n\n    _createClass(ReadableStreamDefaultController, [{\n      key: \"desiredSize\",\n      get: function get() {\n        if (!IsReadableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n      }\n      /**\n       * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n       * the stream, but once those are read, the stream will become closed.\n       */\n\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (!IsReadableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$1('close');\n        }\n\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n          throw new TypeError('The stream is not in a state that permits close');\n        }\n\n        ReadableStreamDefaultControllerClose(this);\n      }\n    }, {\n      key: \"enqueue\",\n      value: function enqueue() {\n        var chunk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$1('enqueue');\n        }\n\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n          throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n      }\n      /**\n       * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n       */\n\n    }, {\n      key: \"error\",\n      value: function error() {\n        var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException$1('error');\n        }\n\n        ReadableStreamDefaultControllerError(this, e);\n      }\n      /** @internal */\n\n    }, {\n      key: CancelSteps,\n      value: function value(reason) {\n        ResetQueue(this);\n\n        var result = this._cancelAlgorithm(reason);\n\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n      }\n      /** @internal */\n\n    }, {\n      key: PullSteps,\n      value: function value(readRequest) {\n        var stream = this._controlledReadableStream;\n\n        if (this._queue.length > 0) {\n          var chunk = DequeueValue(this);\n\n          if (this._closeRequested && this._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            ReadableStreamClose(stream);\n          } else {\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n          }\n\n          readRequest._chunkSteps(chunk);\n        } else {\n          ReadableStreamAddReadRequest(stream, readRequest);\n          ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n      }\n    }]);\n\n    return ReadableStreamDefaultController;\n  }();\n\n  Object.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: {\n      enumerable: true\n    },\n    enqueue: {\n      enumerable: true\n    },\n    error: {\n      enumerable: true\n    },\n    desiredSize: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableStreamDefaultController',\n      configurable: true\n    });\n  } // Abstract operations for the ReadableStreamDefaultController.\n\n\n  function IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n      return false;\n    }\n\n    return x instanceof ReadableStreamDefaultController;\n  }\n\n  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n\n    if (!shouldPull) {\n      return;\n    }\n\n    if (controller._pulling) {\n      controller._pullAgain = true;\n      return;\n    }\n\n    controller._pulling = true;\n\n    var pullPromise = controller._pullAlgorithm();\n\n    uponPromise(pullPromise, function () {\n      controller._pulling = false;\n\n      if (controller._pullAgain) {\n        controller._pullAgain = false;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n      }\n    }, function (e) {\n      ReadableStreamDefaultControllerError(controller, e);\n    });\n  }\n\n  function ReadableStreamDefaultControllerShouldCallPull(controller) {\n    var stream = controller._controlledReadableStream;\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n      return false;\n    }\n\n    if (!controller._started) {\n      return false;\n    }\n\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n      return true;\n    }\n\n    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n\n    if (desiredSize > 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n  } // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n\n\n  function ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n      return;\n    }\n\n    var stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n\n    if (controller._queue.length === 0) {\n      ReadableStreamDefaultControllerClearAlgorithms(controller);\n      ReadableStreamClose(stream);\n    }\n  }\n\n  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n      return;\n    }\n\n    var stream = controller._controlledReadableStream;\n\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n      ReadableStreamFulfillReadRequest(stream, chunk, false);\n    } else {\n      var chunkSize;\n\n      try {\n        chunkSize = controller._strategySizeAlgorithm(chunk);\n      } catch (chunkSizeE) {\n        ReadableStreamDefaultControllerError(controller, chunkSizeE);\n        throw chunkSizeE;\n      }\n\n      try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n      } catch (enqueueE) {\n        ReadableStreamDefaultControllerError(controller, enqueueE);\n        throw enqueueE;\n      }\n    }\n\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  }\n\n  function ReadableStreamDefaultControllerError(controller, e) {\n    var stream = controller._controlledReadableStream;\n\n    if (stream._state !== 'readable') {\n      return;\n    }\n\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n  }\n\n  function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    var state = controller._controlledReadableStream._state;\n\n    if (state === 'errored') {\n      return null;\n    }\n\n    if (state === 'closed') {\n      return 0;\n    }\n\n    return controller._strategyHWM - controller._queueTotalSize;\n  } // This is used in the implementation of TransformStream.\n\n\n  function ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    var state = controller._controlledReadableStream._state;\n\n    if (!controller._closeRequested && state === 'readable') {\n      return true;\n    }\n\n    return false;\n  }\n\n  function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    var startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), function () {\n      controller._started = true;\n      ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, function (r) {\n      ReadableStreamDefaultControllerError(controller, r);\n    });\n  }\n\n  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    var controller = Object.create(ReadableStreamDefaultController.prototype);\n\n    var startAlgorithm = function startAlgorithm() {\n      return undefined;\n    };\n\n    var pullAlgorithm = function pullAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    var cancelAlgorithm = function cancelAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    if (underlyingSource.start !== undefined) {\n      startAlgorithm = function startAlgorithm() {\n        return underlyingSource.start(controller);\n      };\n    }\n\n    if (underlyingSource.pull !== undefined) {\n      pullAlgorithm = function pullAlgorithm() {\n        return underlyingSource.pull(controller);\n      };\n    }\n\n    if (underlyingSource.cancel !== undefined) {\n      cancelAlgorithm = function cancelAlgorithm(reason) {\n        return underlyingSource.cancel(reason);\n      };\n    }\n\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n  } // Helper functions for the ReadableStreamDefaultController.\n\n\n  function defaultControllerBrandCheckException$1(name) {\n    return new TypeError(\"ReadableStreamDefaultController.prototype.\".concat(name, \" can only be used on a ReadableStreamDefaultController\"));\n  }\n\n  function ReadableStreamTee(stream, cloneForBranch2) {\n    if (IsReadableByteStreamController(stream._readableStreamController)) {\n      return ReadableByteStreamTee(stream);\n    }\n\n    return ReadableStreamDefaultTee(stream);\n  }\n\n  function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n    var reader = AcquireReadableStreamDefaultReader(stream);\n    var reading = false;\n    var readAgain = false;\n    var canceled1 = false;\n    var canceled2 = false;\n    var reason1;\n    var reason2;\n    var branch1;\n    var branch2;\n    var resolveCancelPromise;\n    var cancelPromise = newPromise(function (resolve) {\n      resolveCancelPromise = resolve;\n    });\n\n    function pullAlgorithm() {\n      if (reading) {\n        readAgain = true;\n        return promiseResolvedWith(undefined);\n      }\n\n      reading = true;\n      var readRequest = {\n        _chunkSteps: function _chunkSteps(chunk) {\n          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n          // successful synchronously-available reads get ahead of asynchronously-available errors.\n          queueMicrotask(function () {\n            readAgain = false;\n            var chunk1 = chunk;\n            var chunk2 = chunk; // There is no way to access the cloning code right now in the reference implementation.\n            // If we add one then we'll need an implementation for serializable objects.\n            // if (!canceled2 && cloneForBranch2) {\n            //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n            // }\n\n            if (!canceled1) {\n              ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n            }\n\n            if (!canceled2) {\n              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n            }\n\n            reading = false;\n\n            if (readAgain) {\n              pullAlgorithm();\n            }\n          });\n        },\n        _closeSteps: function _closeSteps() {\n          reading = false;\n\n          if (!canceled1) {\n            ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n          }\n\n          if (!canceled2) {\n            ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n          }\n\n          if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n          }\n        },\n        _errorSteps: function _errorSteps() {\n          reading = false;\n        }\n      };\n      ReadableStreamDefaultReaderRead(reader, readRequest);\n      return promiseResolvedWith(undefined);\n    }\n\n    function cancel1Algorithm(reason) {\n      canceled1 = true;\n      reason1 = reason;\n\n      if (canceled2) {\n        var compositeReason = CreateArrayFromList([reason1, reason2]);\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\n        resolveCancelPromise(cancelResult);\n      }\n\n      return cancelPromise;\n    }\n\n    function cancel2Algorithm(reason) {\n      canceled2 = true;\n      reason2 = reason;\n\n      if (canceled1) {\n        var compositeReason = CreateArrayFromList([reason1, reason2]);\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\n        resolveCancelPromise(cancelResult);\n      }\n\n      return cancelPromise;\n    }\n\n    function startAlgorithm() {// do nothing\n    }\n\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, function (r) {\n      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n\n      if (!canceled1 || !canceled2) {\n        resolveCancelPromise(undefined);\n      }\n    });\n    return [branch1, branch2];\n  }\n\n  function ReadableByteStreamTee(stream) {\n    var reader = AcquireReadableStreamDefaultReader(stream);\n    var reading = false;\n    var readAgainForBranch1 = false;\n    var readAgainForBranch2 = false;\n    var canceled1 = false;\n    var canceled2 = false;\n    var reason1;\n    var reason2;\n    var branch1;\n    var branch2;\n    var resolveCancelPromise;\n    var cancelPromise = newPromise(function (resolve) {\n      resolveCancelPromise = resolve;\n    });\n\n    function forwardReaderError(thisReader) {\n      uponRejection(thisReader._closedPromise, function (r) {\n        if (thisReader !== reader) {\n          return;\n        }\n\n        ReadableByteStreamControllerError(branch1._readableStreamController, r);\n        ReadableByteStreamControllerError(branch2._readableStreamController, r);\n\n        if (!canceled1 || !canceled2) {\n          resolveCancelPromise(undefined);\n        }\n      });\n    }\n\n    function pullWithDefaultReader() {\n      if (IsReadableStreamBYOBReader(reader)) {\n        ReadableStreamReaderGenericRelease(reader);\n        reader = AcquireReadableStreamDefaultReader(stream);\n        forwardReaderError(reader);\n      }\n\n      var readRequest = {\n        _chunkSteps: function _chunkSteps(chunk) {\n          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n          // successful synchronously-available reads get ahead of asynchronously-available errors.\n          queueMicrotask(function () {\n            readAgainForBranch1 = false;\n            readAgainForBranch2 = false;\n            var chunk1 = chunk;\n            var chunk2 = chunk;\n\n            if (!canceled1 && !canceled2) {\n              try {\n                chunk2 = CloneAsUint8Array(chunk);\n              } catch (cloneE) {\n                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                return;\n              }\n            }\n\n            if (!canceled1) {\n              ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n            }\n\n            if (!canceled2) {\n              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n            }\n\n            reading = false;\n\n            if (readAgainForBranch1) {\n              pull1Algorithm();\n            } else if (readAgainForBranch2) {\n              pull2Algorithm();\n            }\n          });\n        },\n        _closeSteps: function _closeSteps() {\n          reading = false;\n\n          if (!canceled1) {\n            ReadableByteStreamControllerClose(branch1._readableStreamController);\n          }\n\n          if (!canceled2) {\n            ReadableByteStreamControllerClose(branch2._readableStreamController);\n          }\n\n          if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n          }\n\n          if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n            ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n          }\n\n          if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n          }\n        },\n        _errorSteps: function _errorSteps() {\n          reading = false;\n        }\n      };\n      ReadableStreamDefaultReaderRead(reader, readRequest);\n    }\n\n    function pullWithBYOBReader(view, forBranch2) {\n      if (IsReadableStreamDefaultReader(reader)) {\n        ReadableStreamReaderGenericRelease(reader);\n        reader = AcquireReadableStreamBYOBReader(stream);\n        forwardReaderError(reader);\n      }\n\n      var byobBranch = forBranch2 ? branch2 : branch1;\n      var otherBranch = forBranch2 ? branch1 : branch2;\n      var readIntoRequest = {\n        _chunkSteps: function _chunkSteps(chunk) {\n          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n          // successful synchronously-available reads get ahead of asynchronously-available errors.\n          queueMicrotask(function () {\n            readAgainForBranch1 = false;\n            readAgainForBranch2 = false;\n            var byobCanceled = forBranch2 ? canceled2 : canceled1;\n            var otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n            if (!otherCanceled) {\n              var clonedChunk;\n\n              try {\n                clonedChunk = CloneAsUint8Array(chunk);\n              } catch (cloneE) {\n                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                return;\n              }\n\n              if (!byobCanceled) {\n                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n              }\n\n              ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n            } else if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n\n            reading = false;\n\n            if (readAgainForBranch1) {\n              pull1Algorithm();\n            } else if (readAgainForBranch2) {\n              pull2Algorithm();\n            }\n          });\n        },\n        _closeSteps: function _closeSteps(chunk) {\n          reading = false;\n          var byobCanceled = forBranch2 ? canceled2 : canceled1;\n          var otherCanceled = forBranch2 ? canceled1 : canceled2;\n\n          if (!byobCanceled) {\n            ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n          }\n\n          if (!otherCanceled) {\n            ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n          }\n\n          if (chunk !== undefined) {\n            if (!byobCanceled) {\n              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n            }\n\n            if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n              ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n            }\n          }\n\n          if (!byobCanceled || !otherCanceled) {\n            resolveCancelPromise(undefined);\n          }\n        },\n        _errorSteps: function _errorSteps() {\n          reading = false;\n        }\n      };\n      ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);\n    }\n\n    function pull1Algorithm() {\n      if (reading) {\n        readAgainForBranch1 = true;\n        return promiseResolvedWith(undefined);\n      }\n\n      reading = true;\n      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n\n      if (byobRequest === null) {\n        pullWithDefaultReader();\n      } else {\n        pullWithBYOBReader(byobRequest._view, false);\n      }\n\n      return promiseResolvedWith(undefined);\n    }\n\n    function pull2Algorithm() {\n      if (reading) {\n        readAgainForBranch2 = true;\n        return promiseResolvedWith(undefined);\n      }\n\n      reading = true;\n      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n\n      if (byobRequest === null) {\n        pullWithDefaultReader();\n      } else {\n        pullWithBYOBReader(byobRequest._view, true);\n      }\n\n      return promiseResolvedWith(undefined);\n    }\n\n    function cancel1Algorithm(reason) {\n      canceled1 = true;\n      reason1 = reason;\n\n      if (canceled2) {\n        var compositeReason = CreateArrayFromList([reason1, reason2]);\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\n        resolveCancelPromise(cancelResult);\n      }\n\n      return cancelPromise;\n    }\n\n    function cancel2Algorithm(reason) {\n      canceled2 = true;\n      reason2 = reason;\n\n      if (canceled1) {\n        var compositeReason = CreateArrayFromList([reason1, reason2]);\n        var cancelResult = ReadableStreamCancel(stream, compositeReason);\n        resolveCancelPromise(cancelResult);\n      }\n\n      return cancelPromise;\n    }\n\n    function startAlgorithm() {\n      return;\n    }\n\n    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n    forwardReaderError(reader);\n    return [branch1, branch2];\n  }\n\n  function convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    var original = source;\n    var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    var cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    var pull = original === null || original === void 0 ? void 0 : original.pull;\n    var start = original === null || original === void 0 ? void 0 : original.start;\n    var type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n      autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, \"\".concat(context, \" has member 'autoAllocateChunkSize' that\")),\n      cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, \"\".concat(context, \" has member 'cancel' that\")),\n      pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, \"\".concat(context, \" has member 'pull' that\")),\n      start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, \"\".concat(context, \" has member 'start' that\")),\n      type: type === undefined ? undefined : convertReadableStreamType(type, \"\".concat(context, \" has member 'type' that\"))\n    };\n  }\n\n  function convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (reason) {\n      return promiseCall(fn, original, [reason]);\n    };\n  }\n\n  function convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (controller) {\n      return promiseCall(fn, original, [controller]);\n    };\n  }\n\n  function convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (controller) {\n      return reflectCall(fn, original, [controller]);\n    };\n  }\n\n  function convertReadableStreamType(type, context) {\n    type = \"\".concat(type);\n\n    if (type !== 'bytes') {\n      throw new TypeError(\"\".concat(context, \" '\").concat(type, \"' is not a valid enumeration value for ReadableStreamType\"));\n    }\n\n    return type;\n  }\n\n  function convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    var mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n      mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, \"\".concat(context, \" has member 'mode' that\"))\n    };\n  }\n\n  function convertReadableStreamReaderMode(mode, context) {\n    mode = \"\".concat(mode);\n\n    if (mode !== 'byob') {\n      throw new TypeError(\"\".concat(context, \" '\").concat(mode, \"' is not a valid enumeration value for ReadableStreamReaderMode\"));\n    }\n\n    return mode;\n  }\n\n  function convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return {\n      preventCancel: Boolean(preventCancel)\n    };\n  }\n\n  function convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    var signal = options === null || options === void 0 ? void 0 : options.signal;\n\n    if (signal !== undefined) {\n      assertAbortSignal(signal, \"\".concat(context, \" has member 'signal' that\"));\n    }\n\n    return {\n      preventAbort: Boolean(preventAbort),\n      preventCancel: Boolean(preventCancel),\n      preventClose: Boolean(preventClose),\n      signal: signal\n    };\n  }\n\n  function assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n      throw new TypeError(\"\".concat(context, \" is not an AbortSignal.\"));\n    }\n  }\n\n  function convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    var readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, \"\".concat(context, \" has member 'readable' that\"));\n    var writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, \"\".concat(context, \" has member 'writable' that\"));\n    return {\n      readable: readable,\n      writable: writable\n    };\n  }\n  /**\n   * A readable stream represents a source of data, from which you can read.\n   *\n   * @public\n   */\n\n\n  var ReadableStream = /*#__PURE__*/function () {\n    function ReadableStream() {\n      var rawUnderlyingSource = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rawStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, ReadableStream);\n\n      if (rawUnderlyingSource === undefined) {\n        rawUnderlyingSource = null;\n      } else {\n        assertObject(rawUnderlyingSource, 'First parameter');\n      }\n\n      var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n      var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n      InitializeReadableStream(this);\n\n      if (underlyingSource.type === 'bytes') {\n        if (strategy.size !== undefined) {\n          throw new RangeError('The strategy for a byte stream cannot have a size function');\n        }\n\n        var highWaterMark = ExtractHighWaterMark(strategy, 0);\n        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n      } else {\n        var sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n\n        var _highWaterMark = ExtractHighWaterMark(strategy, 1);\n\n        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, _highWaterMark, sizeAlgorithm);\n      }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n\n\n    _createClass(ReadableStream, [{\n      key: \"locked\",\n      get: function get() {\n        if (!IsReadableStream(this)) {\n          throw streamBrandCheckException$1('locked');\n        }\n\n        return IsReadableStreamLocked(this);\n      }\n      /**\n       * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n       *\n       * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n       * method, which might or might not use it.\n       */\n\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStream(this)) {\n          return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n\n        if (IsReadableStreamLocked(this)) {\n          return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n\n        return ReadableStreamCancel(this, reason);\n      }\n    }, {\n      key: \"getReader\",\n      value: function getReader() {\n        var rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStream(this)) {\n          throw streamBrandCheckException$1('getReader');\n        }\n\n        var options = convertReaderOptions(rawOptions, 'First parameter');\n\n        if (options.mode === undefined) {\n          return AcquireReadableStreamDefaultReader(this);\n        }\n\n        return AcquireReadableStreamBYOBReader(this);\n      }\n    }, {\n      key: \"pipeThrough\",\n      value: function pipeThrough(rawTransform) {\n        var rawOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (!IsReadableStream(this)) {\n          throw streamBrandCheckException$1('pipeThrough');\n        }\n\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        var transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        var options = convertPipeOptions(rawOptions, 'Second parameter');\n\n        if (IsReadableStreamLocked(this)) {\n          throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n\n        if (IsWritableStreamLocked(transform.writable)) {\n          throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n\n        var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n      }\n    }, {\n      key: \"pipeTo\",\n      value: function pipeTo(destination) {\n        var rawOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (!IsReadableStream(this)) {\n          return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n\n        if (destination === undefined) {\n          return promiseRejectedWith(\"Parameter 1 is required in 'pipeTo'.\");\n        }\n\n        if (!IsWritableStream(destination)) {\n          return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n        }\n\n        var options;\n\n        try {\n          options = convertPipeOptions(rawOptions, 'Second parameter');\n        } catch (e) {\n          return promiseRejectedWith(e);\n        }\n\n        if (IsReadableStreamLocked(this)) {\n          return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n\n        if (IsWritableStreamLocked(destination)) {\n          return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n      }\n      /**\n       * Tees this readable stream, returning a two-element array containing the two resulting branches as\n       * new {@link ReadableStream} instances.\n       *\n       * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n       * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n       * propagated to the stream's underlying source.\n       *\n       * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n       * this could allow interference between the two branches.\n       */\n\n    }, {\n      key: \"tee\",\n      value: function tee() {\n        if (!IsReadableStream(this)) {\n          throw streamBrandCheckException$1('tee');\n        }\n\n        var branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n      }\n    }, {\n      key: \"values\",\n      value: function values() {\n        var rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsReadableStream(this)) {\n          throw streamBrandCheckException$1('values');\n        }\n\n        var options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n      }\n    }]);\n\n    return ReadableStream;\n  }();\n\n  Object.defineProperties(ReadableStream.prototype, {\n    cancel: {\n      enumerable: true\n    },\n    getReader: {\n      enumerable: true\n    },\n    pipeThrough: {\n      enumerable: true\n    },\n    pipeTo: {\n      enumerable: true\n    },\n    tee: {\n      enumerable: true\n    },\n    values: {\n      enumerable: true\n    },\n    locked: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ReadableStream',\n      configurable: true\n    });\n  }\n\n  if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n      value: ReadableStream.prototype.values,\n      writable: true,\n      configurable: true\n    });\n  } // Abstract operations for the ReadableStream.\n  // Throws if and only if startAlgorithm throws.\n\n\n  function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n    var highWaterMark = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var sizeAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n      return 1;\n    };\n    var stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    var controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n  } // Throws if and only if startAlgorithm throws.\n\n\n  function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n    var stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    var controller = Object.create(ReadableByteStreamController.prototype);\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n    return stream;\n  }\n\n  function InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n  }\n\n  function IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n      return false;\n    }\n\n    return x instanceof ReadableStream;\n  }\n\n  function IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n      return false;\n    }\n\n    return true;\n  } // ReadableStream API exposed for controllers.\n\n\n  function ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n\n    if (stream._state === 'closed') {\n      return promiseResolvedWith(undefined);\n    }\n\n    if (stream._state === 'errored') {\n      return promiseRejectedWith(stream._storedError);\n    }\n\n    ReadableStreamClose(stream);\n    var reader = stream._reader;\n\n    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n      reader._readIntoRequests.forEach(function (readIntoRequest) {\n        readIntoRequest._closeSteps(undefined);\n      });\n\n      reader._readIntoRequests = new SimpleQueue();\n    }\n\n    var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n\n    return transformPromiseWith(sourceCancelPromise, noop);\n  }\n\n  function ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    var reader = stream._reader;\n\n    if (reader === undefined) {\n      return;\n    }\n\n    defaultReaderClosedPromiseResolve(reader);\n\n    if (IsReadableStreamDefaultReader(reader)) {\n      reader._readRequests.forEach(function (readRequest) {\n        readRequest._closeSteps();\n      });\n\n      reader._readRequests = new SimpleQueue();\n    }\n  }\n\n  function ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    var reader = stream._reader;\n\n    if (reader === undefined) {\n      return;\n    }\n\n    defaultReaderClosedPromiseReject(reader, e);\n\n    if (IsReadableStreamDefaultReader(reader)) {\n      reader._readRequests.forEach(function (readRequest) {\n        readRequest._errorSteps(e);\n      });\n\n      reader._readRequests = new SimpleQueue();\n    } else {\n      reader._readIntoRequests.forEach(function (readIntoRequest) {\n        readIntoRequest._errorSteps(e);\n      });\n\n      reader._readIntoRequests = new SimpleQueue();\n    }\n  } // Helper functions for the ReadableStream.\n\n\n  function streamBrandCheckException$1(name) {\n    return new TypeError(\"ReadableStream.prototype.\".concat(name, \" can only be used on a ReadableStream\"));\n  }\n\n  function convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n      highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n  } // The size function must not have a prototype property nor be a constructor\n\n\n  var byteLengthSizeFunction = function byteLengthSizeFunction(chunk) {\n    return chunk.byteLength;\n  };\n\n  try {\n    Object.defineProperty(byteLengthSizeFunction, 'name', {\n      value: 'size',\n      configurable: true\n    });\n  } catch (_a) {// This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n  /**\n   * A queuing strategy that counts the number of bytes in each chunk.\n   *\n   * @public\n   */\n\n\n  var ByteLengthQueuingStrategy = /*#__PURE__*/function () {\n    function ByteLengthQueuingStrategy(options) {\n      _classCallCheck(this, ByteLengthQueuingStrategy);\n\n      assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n      options = convertQueuingStrategyInit(options, 'First parameter');\n      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n\n\n    _createClass(ByteLengthQueuingStrategy, [{\n      key: \"highWaterMark\",\n      get: function get() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n          throw byteLengthBrandCheckException('highWaterMark');\n        }\n\n        return this._byteLengthQueuingStrategyHighWaterMark;\n      }\n      /**\n       * Measures the size of `chunk` by returning the value of its `byteLength` property.\n       */\n\n    }, {\n      key: \"size\",\n      get: function get() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n          throw byteLengthBrandCheckException('size');\n        }\n\n        return byteLengthSizeFunction;\n      }\n    }]);\n\n    return ByteLengthQueuingStrategy;\n  }();\n\n  Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: {\n      enumerable: true\n    },\n    size: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n      value: 'ByteLengthQueuingStrategy',\n      configurable: true\n    });\n  } // Helper functions for the ByteLengthQueuingStrategy.\n\n\n  function byteLengthBrandCheckException(name) {\n    return new TypeError(\"ByteLengthQueuingStrategy.prototype.\".concat(name, \" can only be used on a ByteLengthQueuingStrategy\"));\n  }\n\n  function IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n      return false;\n    }\n\n    return x instanceof ByteLengthQueuingStrategy;\n  } // The size function must not have a prototype property nor be a constructor\n\n\n  var countSizeFunction = function countSizeFunction() {\n    return 1;\n  };\n\n  try {\n    Object.defineProperty(countSizeFunction, 'name', {\n      value: 'size',\n      configurable: true\n    });\n  } catch (_a) {// This property is non-configurable in older browsers, so ignore if this throws.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n  }\n  /**\n   * A queuing strategy that counts the number of chunks.\n   *\n   * @public\n   */\n\n\n  var CountQueuingStrategy = /*#__PURE__*/function () {\n    function CountQueuingStrategy(options) {\n      _classCallCheck(this, CountQueuingStrategy);\n\n      assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n      options = convertQueuingStrategyInit(options, 'First parameter');\n      this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n\n\n    _createClass(CountQueuingStrategy, [{\n      key: \"highWaterMark\",\n      get: function get() {\n        if (!IsCountQueuingStrategy(this)) {\n          throw countBrandCheckException('highWaterMark');\n        }\n\n        return this._countQueuingStrategyHighWaterMark;\n      }\n      /**\n       * Measures the size of `chunk` by always returning 1.\n       * This ensures that the total queue size is a count of the number of chunks in the queue.\n       */\n\n    }, {\n      key: \"size\",\n      get: function get() {\n        if (!IsCountQueuingStrategy(this)) {\n          throw countBrandCheckException('size');\n        }\n\n        return countSizeFunction;\n      }\n    }]);\n\n    return CountQueuingStrategy;\n  }();\n\n  Object.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: {\n      enumerable: true\n    },\n    size: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n      value: 'CountQueuingStrategy',\n      configurable: true\n    });\n  } // Helper functions for the CountQueuingStrategy.\n\n\n  function countBrandCheckException(name) {\n    return new TypeError(\"CountQueuingStrategy.prototype.\".concat(name, \" can only be used on a CountQueuingStrategy\"));\n  }\n\n  function IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n      return false;\n    }\n\n    return x instanceof CountQueuingStrategy;\n  }\n\n  function convertTransformer(original, context) {\n    assertDictionary(original, context);\n    var flush = original === null || original === void 0 ? void 0 : original.flush;\n    var readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    var start = original === null || original === void 0 ? void 0 : original.start;\n    var transform = original === null || original === void 0 ? void 0 : original.transform;\n    var writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, \"\".concat(context, \" has member 'flush' that\")),\n      readableType: readableType,\n      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, \"\".concat(context, \" has member 'start' that\")),\n      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, \"\".concat(context, \" has member 'transform' that\")),\n      writableType: writableType\n    };\n  }\n\n  function convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (controller) {\n      return promiseCall(fn, original, [controller]);\n    };\n  }\n\n  function convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (controller) {\n      return reflectCall(fn, original, [controller]);\n    };\n  }\n\n  function convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return function (chunk, controller) {\n      return promiseCall(fn, original, [chunk, controller]);\n    };\n  } // Class TransformStream\n\n  /**\n   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n   * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n   * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n   * made available for reading from the readable side.\n   *\n   * @public\n   */\n\n\n  var TransformStream = /*#__PURE__*/function () {\n    function TransformStream() {\n      var rawTransformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var rawWritableStrategy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rawReadableStrategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      _classCallCheck(this, TransformStream);\n\n      if (rawTransformer === undefined) {\n        rawTransformer = null;\n      }\n\n      var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n      var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n      var transformer = convertTransformer(rawTransformer, 'First parameter');\n\n      if (transformer.readableType !== undefined) {\n        throw new RangeError('Invalid readableType specified');\n      }\n\n      if (transformer.writableType !== undefined) {\n        throw new RangeError('Invalid writableType specified');\n      }\n\n      var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n      var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n      var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n      var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n      var startPromise_resolve;\n      var startPromise = newPromise(function (resolve) {\n        startPromise_resolve = resolve;\n      });\n      InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n\n      if (transformer.start !== undefined) {\n        startPromise_resolve(transformer.start(this._transformStreamController));\n      } else {\n        startPromise_resolve(undefined);\n      }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n\n\n    _createClass(TransformStream, [{\n      key: \"readable\",\n      get: function get() {\n        if (!IsTransformStream(this)) {\n          throw streamBrandCheckException('readable');\n        }\n\n        return this._readable;\n      }\n      /**\n       * The writable side of the transform stream.\n       */\n\n    }, {\n      key: \"writable\",\n      get: function get() {\n        if (!IsTransformStream(this)) {\n          throw streamBrandCheckException('writable');\n        }\n\n        return this._writable;\n      }\n    }]);\n\n    return TransformStream;\n  }();\n\n  Object.defineProperties(TransformStream.prototype, {\n    readable: {\n      enumerable: true\n    },\n    writable: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n      value: 'TransformStream',\n      configurable: true\n    });\n  }\n\n  function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n      return startPromise;\n    }\n\n    function writeAlgorithm(chunk) {\n      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n\n    function abortAlgorithm(reason) {\n      return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n\n    function closeAlgorithm() {\n      return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n\n    function pullAlgorithm() {\n      return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n\n    function cancelAlgorithm(reason) {\n      TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n      return promiseResolvedWith(undefined);\n    }\n\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n  }\n\n  function IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n      return false;\n    }\n\n    return x instanceof TransformStream;\n  } // This is a no-op if both sides are already errored.\n\n\n  function TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n  }\n\n  function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n\n    if (stream._backpressure) {\n      // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n      // _backpressure is set.\n      TransformStreamSetBackpressure(stream, false);\n    }\n  }\n\n  function TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n      stream._backpressureChangePromise_resolve();\n    }\n\n    stream._backpressureChangePromise = newPromise(function (resolve) {\n      stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n  } // Class TransformStreamDefaultController\n\n  /**\n   * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n   *\n   * @public\n   */\n\n\n  var TransformStreamDefaultController = /*#__PURE__*/function () {\n    function TransformStreamDefaultController() {\n      _classCallCheck(this, TransformStreamDefaultController);\n\n      throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n\n\n    _createClass(TransformStreamDefaultController, [{\n      key: \"desiredSize\",\n      get: function get() {\n        if (!IsTransformStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException('desiredSize');\n        }\n\n        var readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n      }\n    }, {\n      key: \"enqueue\",\n      value: function enqueue() {\n        var chunk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsTransformStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException('enqueue');\n        }\n\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n      }\n      /**\n       * Errors both the readable side and the writable side of the controlled transform stream, making all future\n       * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n       */\n\n    }, {\n      key: \"error\",\n      value: function error() {\n        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n        if (!IsTransformStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException('error');\n        }\n\n        TransformStreamDefaultControllerError(this, reason);\n      }\n      /**\n       * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n       * transformer only needs to consume a portion of the chunks written to the writable side.\n       */\n\n    }, {\n      key: \"terminate\",\n      value: function terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n          throw defaultControllerBrandCheckException('terminate');\n        }\n\n        TransformStreamDefaultControllerTerminate(this);\n      }\n    }]);\n\n    return TransformStreamDefaultController;\n  }();\n\n  Object.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: {\n      enumerable: true\n    },\n    error: {\n      enumerable: true\n    },\n    terminate: {\n      enumerable: true\n    },\n    desiredSize: {\n      enumerable: true\n    }\n  });\n\n  if (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n      value: 'TransformStreamDefaultController',\n      configurable: true\n    });\n  } // Transform Stream Default Controller Abstract Operations\n\n\n  function IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n      return false;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n      return false;\n    }\n\n    return x instanceof TransformStreamDefaultController;\n  }\n\n  function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n  }\n\n  function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    var controller = Object.create(TransformStreamDefaultController.prototype);\n\n    var transformAlgorithm = function transformAlgorithm(chunk) {\n      try {\n        TransformStreamDefaultControllerEnqueue(controller, chunk);\n        return promiseResolvedWith(undefined);\n      } catch (transformResultE) {\n        return promiseRejectedWith(transformResultE);\n      }\n    };\n\n    var flushAlgorithm = function flushAlgorithm() {\n      return promiseResolvedWith(undefined);\n    };\n\n    if (transformer.transform !== undefined) {\n      transformAlgorithm = function transformAlgorithm(chunk) {\n        return transformer.transform(chunk, controller);\n      };\n    }\n\n    if (transformer.flush !== undefined) {\n      flushAlgorithm = function flushAlgorithm() {\n        return transformer.flush(controller);\n      };\n    }\n\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n  }\n\n  function TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n  }\n\n  function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    var stream = controller._controlledTransformStream;\n    var readableController = stream._readable._readableStreamController;\n\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n      throw new TypeError('Readable side is not in a state that permits enqueue');\n    } // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n\n\n    try {\n      ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    } catch (e) {\n      // This happens when readableStrategy.size() throws.\n      TransformStreamErrorWritableAndUnblockWrite(stream, e);\n      throw stream._readable._storedError;\n    }\n\n    var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n\n    if (backpressure !== stream._backpressure) {\n      TransformStreamSetBackpressure(stream, true);\n    }\n  }\n\n  function TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n  }\n\n  function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    var transformPromise = controller._transformAlgorithm(chunk);\n\n    return transformPromiseWith(transformPromise, undefined, function (r) {\n      TransformStreamError(controller._controlledTransformStream, r);\n      throw r;\n    });\n  }\n\n  function TransformStreamDefaultControllerTerminate(controller) {\n    var stream = controller._controlledTransformStream;\n    var readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    var error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n  } // TransformStreamDefaultSink Algorithms\n\n\n  function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    var controller = stream._transformStreamController;\n\n    if (stream._backpressure) {\n      var backpressureChangePromise = stream._backpressureChangePromise;\n      return transformPromiseWith(backpressureChangePromise, function () {\n        var writable = stream._writable;\n        var state = writable._state;\n\n        if (state === 'erroring') {\n          throw writable._storedError;\n        }\n\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n      });\n    }\n\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n  }\n\n  function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n  }\n\n  function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    var readable = stream._readable;\n    var controller = stream._transformStreamController;\n\n    var flushPromise = controller._flushAlgorithm();\n\n    TransformStreamDefaultControllerClearAlgorithms(controller); // Return a promise that is fulfilled with undefined on success.\n\n    return transformPromiseWith(flushPromise, function () {\n      if (readable._state === 'errored') {\n        throw readable._storedError;\n      }\n\n      ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, function (r) {\n      TransformStreamError(stream, r);\n      throw readable._storedError;\n    });\n  } // TransformStreamDefaultSource Algorithms\n\n\n  function TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false); // Prevent the next pull() call until there is backpressure.\n\n    return stream._backpressureChangePromise;\n  } // Helper functions for the TransformStreamDefaultController.\n\n\n  function defaultControllerBrandCheckException(name) {\n    return new TypeError(\"TransformStreamDefaultController.prototype.\".concat(name, \" can only be used on a TransformStreamDefaultController\"));\n  } // Helper functions for the TransformStream.\n\n\n  function streamBrandCheckException(name) {\n    return new TypeError(\"TransformStream.prototype.\".concat(name, \" can only be used on a TransformStream\"));\n  }\n\n  exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n  exports.CountQueuingStrategy = CountQueuingStrategy;\n  exports.ReadableByteStreamController = ReadableByteStreamController;\n  exports.ReadableStream = ReadableStream;\n  exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n  exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n  exports.ReadableStreamDefaultController = ReadableStreamDefaultController;\n  exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n  exports.TransformStream = TransformStream;\n  exports.TransformStreamDefaultController = TransformStreamDefaultController;\n  exports.WritableStream = WritableStream;\n  exports.WritableStreamDefaultController = WritableStreamDefaultController;\n  exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});"],"names":["_regeneratorRuntime","_classCallCheck","_createClass","_wrapAsyncGenerator","exports","SymbolPolyfill","Symbol","iterator","description","concat","noop","getGlobals","self","window","g","globals","typeIsObject","x","rethrowAssertionErrorRejection","originalPromise","Promise","originalPromiseThen","prototype","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","promiseResolvedWith","value","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","call","uponPromise","undefined","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","queueMicrotask","globalQueueMicrotask","resolvedPromise","fn","reflectCall","F","V","args","TypeError","Function","apply","promiseCall","QUEUE_MAX_ARRAY_SIZE","SimpleQueue","this","_cursor","_size","_front","_elements","_next","_back","key","get","element","oldBack","newBack","length","push","oldFront","newFront","oldCursor","newCursor","elements","callback","i","node","front","cursor","ReadableStreamReaderGenericInitialize","reader","stream","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","defaultReaderClosedPromiseResolve","AbortSteps","ErrorSteps","CancelSteps","PullSteps","NumberIsFinite","Number","isFinite","MathTrunc","Math","trunc","v","ceil","floor","isDictionary","assertDictionary","obj","context","assertFunction","isObject","assertObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","integerPart","convertUnsignedLongLongWithEnforceRange","lowerBound","upperBound","MAX_SAFE_INTEGER","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamFulfillReadRequest","chunk","done","shift","_closeSteps","_chunkSteps","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStreamLocked","defaultReaderBrandCheckException","arguments","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","_errorSteps","e","Object","hasOwnProperty","_disturbed","_readableStreamController","defineProperties","cancel","enumerable","read","releaseLock","closed","toStringTag","defineProperty","configurable","AsyncIteratorPrototype","getPrototypeOf","mark","_callee","wrap","_context","prev","next","stop","ReadableStreamAsyncIteratorImpl","preventCancel","_ongoingPromise","_isFinished","_preventCancel","_this","nextSteps","_nextSteps","_this2","returnSteps","_returnSteps","_this3","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","_asyncIteratorImpl","streamAsyncIteratorBrandCheckException","return","AcquireReadableStreamAsyncIterator","impl","create","_a","setPrototypeOf","NumberIsNaN","isNaN","CreateArrayFromList","slice","CopyDataBlockBytes","dest","destOffset","src","srcOffset","n","Uint8Array","set","TransferArrayBuffer","O","IsDetachedBuffer","ArrayBufferSlice","buffer","begin","end","ArrayBuffer","IsNonNegativeNumber","CloneAsUint8Array","byteOffset","byteLength","DequeueValue","container","pair","_queue","_queueTotalSize","size","EnqueueValueWithSize","Infinity","RangeError","PeekQueueValue","peek","ResetQueue","ReadableStreamBYOBRequest","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","bytesWritten","_associatedReadableByteStreamController","ReadableByteStreamControllerRespond","view","isView","ReadableByteStreamControllerRespondWithNewView","respond","respondWithNewView","ReadableByteStreamController","IsReadableByteStreamController","byteStreamControllerBrandCheckException","ReadableByteStreamControllerGetBYOBRequest","ReadableByteStreamControllerGetDesiredSize","_closeRequested","state","_controlledReadableByteStream","ReadableByteStreamControllerClose","ReadableByteStreamControllerEnqueue","ReadableByteStreamControllerError","ReadableByteStreamControllerClearPendingPullIntos","_cancelAlgorithm","ReadableByteStreamControllerClearAlgorithms","entry","ReadableByteStreamControllerHandleQueueDrain","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","bufferByteLength","bytesFilled","elementSize","viewConstructor","readerType","_pendingPullIntos","ReadableByteStreamControllerCallPullIfNeeded","controller","ReadableByteStreamControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableStreamClose","_byobRequest","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerPullInto","readIntoRequest","constructor","DataView","BYTES_PER_ELEMENT","ctor","ReadableStreamAddReadIntoRequest","emptyView","ReadableByteStreamControllerRespondInClosedState","firstDescriptor","ReadableStreamHasBYOBReader","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerRespondInReadableState","remainderSize","remainder","ReadableByteStreamControllerRespondInternal","_started","transferredBuffer","firstPendingPullInto","ReadableStreamError","byobRequest","SetUpReadableStreamBYOBRequest","_strategyHWM","viewByteLength","SetUpReadableByteStreamController","startAlgorithm","pullAlgorithm","cancelAlgorithm","highWaterMark","r","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","start","pull","request","AcquireReadableStreamBYOBReader","ReadableStreamBYOBReader","_readIntoRequests","IsReadableStreamBYOBReader","close","enqueue","error","desiredSize","byobReaderBrandCheckException","ReadableStreamBYOBReaderRead","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSink","original","abort","type","write","convertUnderlyingSinkAbortCallback","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","isAbortSignal","aborted","supportsAbortController","AbortController","createAbortController","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","InitializeWritableStream","sizeAlgorithm","SetUpWritableStreamDefaultControllerFromUnderlyingSink","streamBrandCheckException$2","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","CreateWritableStream","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","WritableStreamDefaultController","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","_abortReason","_abortController","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","WritableStreamDefaultControllerClose","WritableStreamAddWriteRequest","writeRequest","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","forEach","abortRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamFinishInFlightClose","defaultWriterClosedPromiseResolve","WritableStreamFinishInFlightCloseWithError","WritableStreamMarkCloseRequestInFlight","WritableStreamMarkFirstWriteRequestInFlight","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseReset","getWriter","locked","_ownerWritableStream","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseInitializeAsResolved","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultWriterGetDesiredSize","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterCloseWithErrorPropagation","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","WritableStreamDefaultControllerGetDesiredSize","releasedError","chunkSize","WritableStreamDefaultControllerGetChunkSize","WritableStreamDefaultControllerWrite","closeSentinel","IsWritableStreamDefaultController","defaultControllerBrandCheckException$2","signal","_controlledWritableStream","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_strategySizeAlgorithm","_writeAlgorithm","_closeAlgorithm","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerAdvanceQueueIfNeeded","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","enqueueE","WritableStreamDefaultControllerProcessClose","WritableStreamDefaultControllerProcessWrite","sinkClosePromise","_readyPromise_resolve","_readyPromise_reject","abortReason","NativeDOMException","DOMException","isDOMExceptionConstructor","createDOMExceptionPolyfill","message","Error","captureStackTrace","writable","DOMException$1","ReadableStreamPipeTo","source","preventClose","preventAbort","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","addEventListener","pipeLoop","resolveLoop","rejectLoop","pipeStep","resolveRead","rejectRead","isOrBecomesErrored","shutdown","isOrBecomesClosed","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException$1","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","ReadableStreamDefaultControllerHasBackpressure","SetUpReadableStreamDefaultController","SetUpReadableStreamDefaultControllerFromUnderlyingSource","underlyingSource","ReadableStreamTee","cloneForBranch2","ReadableByteStreamTee","ReadableStreamDefaultTee","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","readAgain","canceled1","canceled2","cancelPromise","chunk1","chunk2","cancel1Algorithm","compositeReason","cancelResult","cancel2Algorithm","CreateReadableStream","readAgainForBranch1","readAgainForBranch2","forwardReaderError","thisReader","pullWithDefaultReader","cloneE","pull1Algorithm","pull2Algorithm","pullWithBYOBReader","forBranch2","byobBranch","otherBranch","byobCanceled","clonedChunk","otherCanceled","CreateReadableByteStream","convertUnderlyingDefaultOrByteSource","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertReaderOptions","options","mode","convertReadableStreamReaderMode","convertIteratorOptions","Boolean","convertPipeOptions","assertAbortSignal","convertReadableWritablePair","readable","ReadableStream","rawUnderlyingSource","InitializeReadableStream","streamBrandCheckException$1","rawOptions","rawTransform","transform","destination","convertQueuingStrategyInit","getReader","pipeThrough","pipeTo","tee","values","asyncIterator","byteLengthSizeFunction","ByteLengthQueuingStrategy","_byteLengthQueuingStrategyHighWaterMark","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","_countQueuingStrategyHighWaterMark","IsCountQueuingStrategy","countBrandCheckException","convertTransformer","flush","readableType","writableType","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","startPromise_resolve","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","InitializeTransformStream","SetUpTransformStreamDefaultControllerFromTransformer","_transformStreamController","IsTransformStream","streamBrandCheckException","_readable","_writable","startPromise","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamDefaultSinkAbortAlgorithm","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","_backpressureChangePromise","_backpressureChangePromise_resolve","TransformStreamSetBackpressure","TransformStreamError","TransformStreamDefaultControllerClearAlgorithms","TransformStreamDefaultController","IsTransformStreamDefaultController","defaultControllerBrandCheckException","_controlledTransformStream","TransformStreamDefaultControllerEnqueue","TransformStreamDefaultControllerError","TransformStreamDefaultControllerTerminate","SetUpTransformStreamDefaultController","transformAlgorithm","flushAlgorithm","_transformAlgorithm","_flushAlgorithm","transformResultE","readableController","TransformStreamDefaultControllerPerformTransform","flushPromise","terminate","factory"],"sourceRoot":""}